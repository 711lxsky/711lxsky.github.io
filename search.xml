<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>EasyDB 项目回顾</title>
      <link href="/2024/05/31/blog21/"/>
      <url>/2024/05/31/blog21/</url>
      
        <content type="html"><![CDATA[<h1>EasyDB 项目回顾</h1><p>最近为简历头疼死了😐，总感觉之前投的简历没写好，而且挺久没看这个项目了，忽然想起来貌似之前有篇博客说要写篇关于这个项目的文章，好吧，那就回顾回顾正好写写</p><p>除了这个轮子项目还有一个微服务直播项目，有空也写写(<s>立Flag小能手</s>)🙃，那个业务上写的挺好的感觉</p><h2 id="实现功能">实现功能</h2><p>俺就不像简历上的那样逐字逐句斟酌了，简单随随便便写写</p><h3 id="列一下">列一下</h3><ol><li>事务持久化</li><li>计数缓存框架</li><li>日志持久化 + <code>WAL</code>机制</li><li>第一检验页面和普通页面 + 可靠数据检测恢复机制</li><li>页面索引(比较简陋)</li><li>数据共享类和全局统一数据类</li><li><code>MVCC</code> + <code>2PL</code> + 等待图死锁检测 和基于此的调度序列可串行化 + 读已提交、可重复读事务隔离级别</li><li><code>B+树</code>结构的索引</li><li>分词器和<code>SQL</code>解析器</li><li>表字段、结构管理器</li><li>基于<code>Socket</code>的客户端服务端通信加密机制</li></ol><h3 id="小小说明">小小说明</h3><h4 id="持久化">持久化</h4><p>这里持久化都是放在文件中去做的，所以每次从持久层读都是做<code>磁盘IO</code>，是比较消耗资源的</p><h4 id="计数缓存">计数缓存</h4><p>于是就弄了个技术缓存框架，存放资源的引用情况，当某个资源释放到了引用为0时就直接写回磁盘文件，框架的意思就是提供静态方法直接使用和抽象方法让子类去实现，所以每个缓存实现类都有从数据源/持久层拿到资源的能力</p><h4 id="日志-WAL">日志 WAL</h4><p>日志说的是数据库操作的日志，不是项目的日志，日志中存储的是数据操作的记录，<code>WAL(Write-Ahead Logging)</code>即预写式日志，每次数据修改之前先将修改记录落到日志，同时确保其已经刷新到磁盘，再做真正的数据修改</p><h4 id="页面设计">页面设计</h4><p>页面设计的是固定大小，然后第一页有个特殊用处是做数据校验，每次启动数据库会先将某个字符串写入第一页的某个位置，然后正常关闭时在另一个位置写入同一条字符串；下一次启动时查看这两处的字符串是否一致，不一致就执行<code>redo重做事务</code>和<code>undo回滚事务</code></p><p>页面索引机制则是将页面划分为<code>40</code>个区间，然后以每个页面的空闲区间数量为关键字存到哈希表中，值则是一个页号列表，每次需要将数据写入页面中就从能够满足空间需求的页号列表中拿出一个页面写入</p><h4 id="数据传递管理">数据传递管理</h4><p>因为<code>Java</code>取一个数组的分片时，时拷贝这段分片内存中的数据，所以设计一个数据共享类，数据放在一个字节数组中，每次将这个数据传递，并给使用这个数组不同的模块设置不同的起始、结束位置</p><h4 id="并发控制调度序列">并发控制调度序列</h4><p>版本管理中，抽象出一个记录，每个记录会标识创建、删除本身的事务；再维护活跃事务快照；</p><p>针对每个事务，看到的都是某个时间点的数据库版本，记录当时的事务快照，这样<code>MVCC多版本并发控制</code>就可以实现；</p><p>再基于<code>两段锁(2PL)</code>协议，读和插入时不用在版本管理模块申请锁，而在记录被修改时删除原记录(标识，非真删)时才强制加锁，事务完成记录修改或者回滚时进行解锁，整个过程中相较于单纯的<code>2PL</code>就降低了阻塞概率；</p><p>另外加锁时还会利用等待图法，使用深度优先遍历方法进行环检测，有环就是有死锁，有死锁就会尝试回滚这个尝试加锁的事务</p><h4 id="B-树索引">B+树索引</h4><p>这里实现了<code>B+树</code>结构，当时写的时候感觉挺难搞</p><p>非叶子节点存储索引数据，叶子节点存储真实数据，同层节点以链表形式连接，单个节点设置有平衡因子，超过这个因子的<code>2倍</code>时进行分裂操作</p><h4 id="SQL解析">SQL解析</h4><p>先写了个分词器，根据特定语法结构将<code>SQL语句</code>进行分割并向外提供逐个读取的方法，然后解析器就利用分词器和字符串匹配，解析不同类型的语句并返回特殊定义的相应结果</p><p>其实按道理应该是使用语法树 + 过滤器</p><h4 id="表字段、结构管理器">表字段、结构管理器</h4><p>这里就根据不同类型的语句解析解析结果，调用下层的数据模块、版本模块、事务模块做数据持久化、缓存操作</p><h4 id="通信">通信</h4><p>其实这里使用的就是<code>Java</code>原生的<code>Socket</code>，服务端和客户端各自创建<code>ServerSocket</code>和<code>ClientSocket</code>，然后去做连接，这里也比较简陋简单</p><h2 id="整体架构模块">整体架构模块</h2><h3 id="通用模块">通用模块</h3><ol><li>AbstractCache 抽象缓存层</li><li>SubArray 数据共享层</li></ol><h3 id="核心层">核心层</h3><ol><li>TransactionManager（TM）事物管理模块</li><li>DataManager（DM）数据管理模块</li><li>VersionManager（VM）版本管理模块</li><li>IndexManager（IM）索引管理模块</li><li>StatementParser（SP）语句解析模块</li><li>TableManager（TBM）表管理模块</li></ol><h3 id="通信层">通信层</h3><ol><li>Transpoter 数据传输器</li><li>Server 服务端</li><li>Client 客户端</li></ol><h2 id="模块解析">模块解析</h2><p>针对每个模块稍稍详细地写了些，贴了些源码，整个项目源码可以直接看仓库 -&gt; <a href="https://github.com/711lxsky/EasyDB">EasyDB</a></p><h3 id="缓存框架">缓存框架</h3><ul><li><input type="checkbox" id="checkbox0"><label for="checkbox0">这里可能被拷打，缓存策略、实现机制</label></li></ul><p>这里使用的是计数缓存框架，不使用<code>LRU</code>是因为考虑到资源驱逐不可控，而使用计数缓存则可以让上层模块主动释放引用，确保模块中不存在这个资源的引用，再去释放资源</p><h4 id="实现机制">实现机制</h4><h5 id="1-成员变量和构造函数：">1. 成员变量和构造函数：</h5>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 缓存数据</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Long, T&gt; cacheData;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存中资源引用个数标记</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Long, Integer&gt; referenceRecord;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  从数据源/持久区中获取资源的记录情况</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;Long, Boolean&gt; acquisitionSituation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存最大资源数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> maxResourceNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现有缓存资源数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> cacheCounter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AbstractCache</span><span class="params">(<span class="type">int</span> maxResourceNum)</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">    <span class="keyword">if</span>(maxResourceNum &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        Log.logErrorMessage(ErrorMessage.CACHE_RESOURCE_NUMBER_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.maxResourceNum = maxResourceNum;</span><br><span class="line">    <span class="built_in">this</span>.cacheData = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.referenceRecord = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.acquisitionSituation = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="built_in">this</span>.lock = <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="built_in">this</span>.cacheCounter = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最大缓存资源数设置为一个配置项</p><h5 id="2-抽象方法：">2. 抽象方法：</h5>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 当资源不在缓存中时，从数据源加载获取</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> T <span class="title function_">getCacheFromDataSourceByKey</span><span class="params">(<span class="type">long</span> cacheKey)</span> <span class="keyword">throws</span> ErrorException, WarningException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 释放缓存，并写回文件/磁盘</span></span><br><span class="line"><span class="comment"> * 写回一般指的是将脏页数据写入到对应硬盘或者其他持久化存储设备中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">releaseCacheForObject</span><span class="params">(T Object)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这两个抽象方法是具体的缓存实现类继承后去做的，分别是从数据源获取数据（类似从磁盘读）和释放缓存时的写回操作（写入持久化文件/磁盘）</p><h5 id="3-操作逻辑：">3. 操作逻辑：</h5><p>类中提供两个方法：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 获取某个资源，可能是从缓存中拿到，也可能是去获取，然后放入缓存</span></span><br><span class="line"><span class="comment"> * 所以这个方法本身也就是在获取缓存数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">getResource</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> WarningException, ErrorException &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="built_in">this</span>.lock.lock();</span><br><span class="line">        <span class="comment">// 如果请求的资源一直在被其他线程获取，就反复等待尝试</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.acquisitionSituation.containsKey(key))&#123;</span><br><span class="line">            <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(ThreadSetting.CACHE_GET_SLEEP_TIME);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Log.logWarningMessage(e.getMessage());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果资源在缓存中，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.cacheData.containsKey(key))&#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">object</span> <span class="operator">=</span> <span class="built_in">this</span>.cacheData.get(key);</span><br><span class="line">            <span class="comment">// 拿到资源，给引用数+1</span></span><br><span class="line">            <span class="built_in">this</span>.referenceRecord.put(key, <span class="built_in">this</span>.referenceRecord.get(key) + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">            <span class="keyword">return</span> object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 尝试获取该资源并放入缓存</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.maxResourceNum &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">this</span>.cacheCounter == <span class="built_in">this</span>.maxResourceNum)&#123;</span><br><span class="line">            <span class="comment">// 缓存已经满了</span></span><br><span class="line">            <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">            Log.logWarningMessage(WarningMessage.CACHE_FULL);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 缓存没满，在资源获取中注册一下，准备从数据源获取资源</span></span><br><span class="line">        <span class="built_in">this</span>.acquisitionSituation.put(key, <span class="literal">true</span>);</span><br><span class="line">        <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.lock.lock();</span><br><span class="line">    T object;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        object = <span class="built_in">this</span>.getCacheFromDataSourceByKey(key);</span><br><span class="line">        <span class="built_in">this</span>.cacheData.put(key, object);</span><br><span class="line">        <span class="built_in">this</span>.cacheCounter ++;</span><br><span class="line">        <span class="built_in">this</span>.referenceRecord.put(key, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">this</span>.acquisitionSituation.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 释放一个资源引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">releaseOneReference</span><span class="params">(<span class="type">long</span> key)</span> <span class="keyword">throws</span> WarningException, ErrorException &#123;</span><br><span class="line">    <span class="built_in">this</span>.lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 把引用数 - 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">referenceNum</span> <span class="operator">=</span> <span class="built_in">this</span>.referenceRecord.get(key) - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果接下来资源没有被引用，就释放写回</span></span><br><span class="line">        <span class="keyword">if</span>(referenceNum == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> cacheData.get(key);</span><br><span class="line">            <span class="built_in">this</span>.releaseCacheForObject(obj);</span><br><span class="line">            <span class="built_in">this</span>.referenceRecord.remove(key);</span><br><span class="line">            <span class="built_in">this</span>.cacheData.remove(key);</span><br><span class="line">            <span class="built_in">this</span>.cacheCounter --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.referenceRecord.put(key, referenceNum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>getResource()方法</code>先在一个<code>while循环</code>中不断申请资源，如果在资源获取情况记录表中别的资源正在从数据源拿到这个资源就<code>让线程sleep</code>，直到没有其他线程获取这个资源，然后如果缓存就在缓存资源表中就直接拿到返回，同时将<code>引用次数 + 1</code>；如果不在其中，就先判断是否达到最大缓存数量，再在资源获取表中注册一下，调用实现类的获取资源方法，跳出循环，如果获取成功就放入缓存。</li><li><code>releaseOneReference()方法</code>释放资源引用时，先将<code>引用表中的引用数 - 1</code>，如果<code>降到0</code>了，说明这个资源没有被引用，可以被释放了，就调用实现类的释放资源写回持久区的方法，同时移除删除这个缓存</li><li>这两个方法执行的过程中都有加解锁操作，就是为了保证线程安全，缓存资源数据不会出现紊乱</li></ul><h5 id="4-安全关闭">4. 安全关闭</h5><p>此外，还有一个安全关闭策略，用于缓存关闭时强制将资源全部写回持久区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 安全关闭缓存，并将资源数据写回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> ErrorException, WarningException &#123;</span><br><span class="line">       <span class="built_in">this</span>.lock.lock();</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           Set&lt;Long&gt; keys = <span class="built_in">this</span>.cacheData.keySet();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">long</span> key: keys)&#123;</span><br><span class="line">               <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="built_in">this</span>.cacheData.get(key);</span><br><span class="line">               <span class="built_in">this</span>.releaseCacheForObject(obj);</span><br><span class="line">               <span class="built_in">this</span>.cacheData.remove(key);</span><br><span class="line">               <span class="built_in">this</span>.referenceRecord.remove(key);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="built_in">this</span>.lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="SubArray-数据共享层">SubArray 数据共享层</h3><p>因为Java中数组分片截取时，是做一个元素复制，而不是指向同一片内存，所以针对截取部分数组的修改对原数组不可见，这里封装了一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 原始数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] rawData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据开始位置标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据结束位置标记</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SubArray</span><span class="params">(<span class="type">byte</span>[] rawData, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rawData = rawData;</span><br><span class="line">        <span class="built_in">this</span>.start = start;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递类实例的时候，对数据进行修改了可以感知到</p><h3 id="TransactionManager（TM）">TransactionManager（TM）</h3><h4 id="概述">概述</h4><p>作为事物管理模块，以<code>XID</code>为第一关键字，将所有事务信息持久化在<code>.xid文件</code>中。并提供接口供其他模块查询某个事务的状态</p><h4 id="事务状态">事务状态</h4><p>设为全局常量，放在一个常量配置类中，有三种:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务状态，正在执行，已提交，已撤销</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">TRANSACTION_ACTIVE</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">TRANSACTION_COMMITTED</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">byte</span> <span class="variable">TRANSACTION_ABORTED</span> <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h4 id="特殊">特殊</h4><ol><li>提供一个超级事务，这个事务的<code>XID为0</code>，可以在没有申请的事务的情况下执行某些操作。且超级事务<code>状态永远是committed</code></li><li>TM模块只负责记录、维护某个事务状态，涉及事务数据提交、回滚另有数据管理模块做</li></ol><h4 id="xid文件结构">.xid文件结构</h4><p>每个事务都有一个<code>XID</code>，这个<code>XID唯一标识</code>此事务，且<code>XID从1开始自增</code>，不可重复（相对单个的<code>.xid文件</code>而言，如果不在同一个文件自然可以重复）。<br>文件头部有一个<code>8字节</code>大小的数字，记录当前文件中的事务数量，然后每个事务的状态占据<code>1个字节</code></p><p>所以结构是这样：<br>[t_cnt 事务个数(8字节)][t_status 事务状态(1字节)]…<br>某个<code>XID = x_id</code>的事务状态存储在<code>(x_id - 1) + 8</code>字节位置(<code>XID=0</code>的超级事务不需记录)</p><h4 id="提供接口">提供接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 开启新事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">begin</span><span class="params">()</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 提交新事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 取消事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 查询某个事务状态是否为活动状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isActive</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 查询某个事务状态是否为已提交状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isCommitted</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 查询某个事务状态是否为已回滚状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isAborted</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 关闭事务管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> ErrorException;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据某个路径创建一个新的事务管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">static</span> TransactionManagerImpl <span class="title function_">create</span><span class="params">(String xidFileFullName)</span> <span class="keyword">throws</span> WarningException, ErrorException &#123;</span><br><span class="line">    <span class="comment">// 创建基础文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> FileManager.createFile(xidFileFullName + TMSetting.XID_FILE_SUFFIX);</span><br><span class="line">    <span class="keyword">return</span> buildTMWithFile(newFile, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据某个路径打开一个事务管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> TransactionManagerImpl <span class="title function_">open</span><span class="params">(String xidFileFullName)</span> <span class="keyword">throws</span> WarningException, ErrorException &#123;</span><br><span class="line">    <span class="comment">// 创建基础文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">newFile</span> <span class="operator">=</span> FileManager.openFile(xidFileFullName + TMSetting.XID_FILE_SUFFIX);</span><br><span class="line">    <span class="keyword">return</span> buildTMWithFile(newFile, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现逻辑要点">实现逻辑要点</h4><ul><li><input type="checkbox" id="checkbox1"><label for="checkbox1">这里可能是面试拷打点，</label><code>NIO</code>、文件</li></ul><h5 id="xid文件类型和读取">.xid文件类型和读取</h5><p><code>.xid文件</code>使用的类型使用的是<code>RandomAccessFile</code>，文件读写基于从其中拿到的<code>FileChannel</code></p><ul><li>首先，<code>RandomAccessFile</code>提供文件的随机访问能力，允许程序直接跳转到文件的任意位置进行读写操作。</li><li>其次，<code>FileChannel</code>是<code>Java NIO</code>的一部分，支持<strong>直接缓冲区</strong>和<strong>内存映射文件</strong>，这允许操作系统在不涉及<code>Java</code>堆的情况下处理大文件，减少数据拷贝，提高性能；另外还提供文件锁定功能，实现文件或文件区域的独占访问，在多线程环境下保证数据一致性</li></ul><h5 id="计数器校验">计数器校验</h5><p>打开<code>.xid文件</code>并创建一个<code>TransactionManager实现类实例</code>时，会校验<code>.xid文件头</code>，先是看文件长度会不会小于计数器长度，然后根据计数器算出事务数量以及相应需要的文件长度，和实际文件长度对比</p><h5 id="计数器操作">计数器操作</h5><p>实现类中有一个锁成员变量，用以在修改计数器时进行加解锁操作，防止其他线程修改，造成数据不一致</p><h5 id="接口实现">接口实现</h5><ul><li><code>begin()</code>: 先将计数器 + 1 位置的事务状态设置为执行中，再自增计数器</li><li><code>close()</code>: 关闭<code>RandomAccessFile</code>和<code>FileChannel</code></li><li>其他方法就是根据<code>XID</code>从相应位置读出状态或者更新状态 or 加以判断(中间包含校验超级事务逻辑)</li></ul><h3 id="DM-数据管理模块">DM 数据管理模块</h3><p><code>DM模块</code>管理数据库<code>DB文件</code>和日志文件。</p><p>主要职责：</p><ul><li>分页管理<code>DB文件</code>，并缓存</li><li>管理日志文件，保证在发生错误时可以根据日志进行恢复</li><li>抽象<code>DB文件</code>为<code>DataItem</code>供上层模块调用</li></ul><p>所以，<code>DM模块</code>是上层模块和文件系统至之间的抽象层，向下读写文件，向上提供数据包装，再加上一个日志功能</p><h4 id="对外提供接口">对外提供接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 以DataItem形式读取并返回数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DataItem <span class="title function_">readDataItem</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 插入数据，先包裹成DataRecord格式，然后再借助页面索引插入到相应的页中，返回uid</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">long</span> <span class="title function_">insertData</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 调用Logger的writeLog方法，将日志写入到日志文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">(<span class="type">byte</span>[] log)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 释放一个DataItem对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">releaseOneDataItem</span><span class="params">(<span class="type">long</span> uid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 关闭相应的资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> ErrorException, WarningException;</span><br></pre></td></tr></table></figure><p>除了这些，还有create()和open()方法，前者会调用PageCache和Logger进行相应文件创建，后者则是打开并校验数据</p><h4 id="实现逻辑">实现逻辑</h4><h5 id="页面">页面</h5><p>针对文件系统，将其抽象成为页面，每次对文件系统的读写都是以页面为单位，且这里将单个页面的大小设置为<code>8KB</code>，放在配置类中，可修改</p><h6 id="页面缓存">页面缓存</h6><p>有一个页面缓存的实现，这个缓存对外提供接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 拿到数据库文件中的页数，表示有多少个页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getPagesNumber</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 新建一个页面到数据库文件，并放入需要存放的数据，返回页号</span></span><br><span class="line"><span class="comment"> * 这里并没有自动放到缓存里</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">buildNewPageWithData</span><span class="params">(<span class="type">byte</span>[] initData)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 根据页号，从缓存中获取页面</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Page <span class="title function_">getPageByPageNumber</span><span class="params">(<span class="type">int</span> pageNumber)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 释放一个页面资源引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">releaseOneReference</span><span class="params">(Page page)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 这个方法是用来恢复数据或者其他场景下，截断页面文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">truncatePageWithMPageNum</span><span class="params">(<span class="type">int</span> maxPageNumber)</span> <span class="keyword">throws</span> WarningException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 刷新页面缓存到文件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flushPage</span><span class="params">(Page page)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 关闭页面缓存，这里是基于RandomAccessFile实现，需要关闭资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> ErrorException;</span><br></pre></td></tr></table></figure><p>同时类似于<code>TM</code>，会创建或者打开一个<code>.pg</code>文件，用以做页面数据的持久化，不同的是加入了一个<code>long类型</code>的<code>memory内存大小</code>参数，用以计算数据页资源的最大缓存数量</p><p>实现类中，成员变量有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 页面数据文件</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RandomAccessFile pageDataFile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据文件通道</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> FileChannel pageFileChannel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 记录当前打开的页面数据文件所含页面的页数，</span></span><br><span class="line"><span class="comment">   * 此数据在打开时就会被计算，并在创建页面时自增</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger pageNumbers;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 放锁，防止多个线程同时操作文件造成数据不一致</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock pageFileLock;</span><br></pre></td></tr></table></figure><p>所以新建一个页面时，就自增原子数据，然后将数据包裹为通用<code>Page对象</code>，写入刷新到<code>.pg文件</code>中</p><p>前面说了单个页面数据的大小，所以需要拿到某个页面的数据时，偏移量就是<code> (long) (pageNumber - 1) * PageSetting.PAGE_SIZE;</code></p><p>至于从数据源拿到缓存资源，这里的key就是页面号，算到偏移量之后直接读数据；释放资源写回文件操作是，判断这个<code>page</code>是否是脏页，是的话就写回</p><p>截断页面方法，是为了为恢复数据作铺垫，直接将<code>.pg文件</code>截断到某个长度</p><h6 id="页面对象">页面对象</h6><p>这里首先有一个通用的页面接口Page</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 加锁，或者这个页面读写的时候上锁，保证数据一致性</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 释放锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 释放页面缓存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">releaseOneReference</span><span class="params">()</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 设置页面数据的脏标记</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">setDirtyStatus</span><span class="params">(Boolean status)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 判断页面是不是脏数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isDirty</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获取页面的页号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">int</span> <span class="title function_">getPageNumber</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获取页面数据的字节形式的原始数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">byte</span>[] getPageData();</span><br></pre></td></tr></table></figure><p>落到实现类上去也很简单，成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 页面页号，从 1 开始</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> pageNumber;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 页面包含的字节数组形式数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  脏状态标记</span></span><br><span class="line"><span class="comment">    * 脏的话意味着缓存中的数据和内存/持久层中的数据不一致，缓存驱逐时务必写回</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> dirtyStatus;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 页面缓存</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> PageCache pageCache;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 页面锁，资源控制</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br></pre></td></tr></table></figure><p>唯一需要注意的就是<code>PageCache</code>的使用，释放一个资源时，就是释放本身</p><p>其次是第一页，这个页面用以做数据库启动时的数据校验，<code>DB启动</code>时，给<code>100~107字节</code>处填入一个随机字节<code>ValidCheck</code>，<code>DB关闭时</code>再将其拷贝到<code>108～115字节</code>处（这个位置可调）， 数据库每次启动时，会检查两处字节是否相同，以此判断上一次是否正常关闭。如果非正常关闭，就需要执行数据恢复</p><p>再就是普通页，这个页在文件中的结构是  [页头][存储数据] 页头是个<code>2字节</code>的无符号整形，记录了当前页的空闲空间的偏移量<br>此类就提供一些数据修改的方法</p><p><strong>注意</strong>： 第一页和普通页提供的都是静态方法，数据都是持久化在<code>.pg文件</code>中的，是由<code>通用Page</code>控制的</p><h5 id="日志">日志</h5><h6 id="对外提供接口-2">对外提供接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 写入日志</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">writeLog</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 定位指针到日志数据起始位置</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">rewind</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 读取下一条日志信息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">byte</span> [] readNextLogData() <span class="keyword">throws</span> ErrorException, WarningException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 截断日志文件到指定长度</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">truncate</span><span class="params">(<span class="type">long</span> length)</span> <span class="keyword">throws</span> WarningException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 关闭日志</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> <span class="keyword">throws</span> ErrorException;</span><br></pre></td></tr></table></figure><p>持久化也是基于一个<code>.log文件</code></p><h6 id="具体实现">具体实现</h6><p>实现类的成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 日志文件</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> RandomAccessFile logFile;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 日志文件通道</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> FileChannel logFileChannel;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 资源锁</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Lock lock;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 日志文件位置指针</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> logFileLocationPointer;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 日志文件原始长度，读取日志的时候不去改动</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">long</span> logFileOriginLength;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 日志文件总校验和</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="type">int</span> logsChecksum;</span><br></pre></td></tr></table></figure><p>日志文件的格式：<br>[LogsChecksum] [Log1] [Log2] … [LogN] [BadTail]</p><ul><li><code>LogsChecksum</code>为后续所有日志计算的<code>Checksum</code>，<code>4字节int</code>类型</li><li><code>Log1...LogN</code>是常规日志数据</li><li><code>BadTail</code>是在数据库崩溃时，没有来得及写完的日志数据，这个<code>BadTail</code>不一定存在</li></ul><p>单条日志记录格式：</p><ul><li>[Size][Checksum][Data]</li><li><code>Size</code>标记<code>Data</code>字段的字节数, <code>4字节int</code>类型</li><li><code>Checksum</code>是该条数据的校验和， <code>4字节int</code>类型</li><li><code>Data</code>是实际的数据</li></ul><p>日志数据类型分为插入和更新，没有删除是因为直接将这条数据的有效标志位设为<code>invalidate</code>即可</p><p>单条日志的校验和基于一个种子算出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 根据种子计算校验和</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">calculateChecksum</span><span class="params">(<span class="type">int</span> logChecksum, <span class="type">byte</span>[] log)</span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">byte</span> littleData : log)&#123;</span><br><span class="line">           logChecksum = logChecksum * LoggerSetting.LOGGER_SEED + littleData;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> logChecksum;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>实现类有一个用于读取下一条日志的方法，可以为其他模块提供迭代读取日志数据的功能</p><p>另外还提供一个截断方法，将<code>FileChannel</code>截断到指定位置</p><h5 id="恢复策略">恢复策略</h5><p>有一个<code>Recover类</code>，专门用于进行数据恢复</p><p>调用日志模块，迭代读取每条日志，并拿到最大的<code>事务xid</code>，以<code>此xid</code>为基准，截断页面文件，再从前到后顺序<code>redo重做</code>所有状态不是活跃（也就是已提交和撤销）的事务；从后到前<code>undo逆序回滚</code>所有未完成（也就是活跃）的事务</p><h5 id="页面索引">页面索引</h5><p>页面空间在页面索引管理视角下，是被分割成<code>40个</code>(默认，可调)小区间的，<br>初始时空闲区间数量就是<code>40</code>, 然后用着用着就会减少空间，空闲区间数量会减少<br>所以页面索引就以空闲区间的数量为基准，管理页面，每次写一个页面时，就会按照需要的空间大小去找合适的页面</p><p>在启动时，就会遍历所有的页面信息，获取页面的空闲空间，安排到这<code>40个</code>区间中<br><code>insert</code>在请求一个页时，会首先将所需的空间向上取整，映射到某一个区间，随后取出这个区间的任何一页，都可以满足需求<br>实现的逻辑是在能满足空间要求的情况下，优先去找空闲空间更小的页面</p><p>注意：插入时被选择的页会被直接从<code>PageIndex</code>中暂时移除，上层模块调用完之后再重新插入</p><h5 id="DataItem">DataItem</h5><p><code>DM层</code>向上提供的数据抽象接口，上层模块通过地址，向<code>DM</code>请求到相应的<code>DataItem</code>,再获取数据<br><code>DataItem</code>中保存的数据结构<code>DataRecord</code>格式：<br>[Valid][DataSize][Data]</p><ul><li><code>Valid</code>: <code>1字节</code>, 用于标记数据是否有效，<code>1有效</code>， <code>0无效</code></li><li><code>DataSize</code>: <code>2字节</code>， 标识<code>Data的大小</code></li></ul><h6 id="提供接口-2">提供接口</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获取DataRecord数据记录，非完整原始数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   SubArray <span class="title function_">getDataRecord</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获取完整原始数据记录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   SubArray <span class="title function_">getRawDataRecord</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 检查数据是否有效</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 在修改数据之前进行的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">beforeModify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 撤销修改操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">unBeforeModify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 数据修改之后的操作</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">afterModify</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 释放一个引用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">releaseOneReference</span><span class="params">()</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 读锁申请</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">readLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 读锁释放</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">readUnlock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 写锁申请</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">writeLock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 写锁释放</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">void</span> <span class="title function_">writeUnlock</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 拿到数据页</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   Page <span class="title function_">getPage</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获取DataItem的唯一标识</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">long</span> <span class="title function_">getUid</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 获取原始数据记录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">byte</span>[] getOldDataRecord();</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 包裹Data构建DataRecord</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="type">byte</span>[] buildDataRecord(<span class="type">byte</span>[] data)&#123;</span><br><span class="line">       <span class="type">byte</span>[] valid = <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;DataItemSetting.DATA_VALID&#125;;</span><br><span class="line">       <span class="type">byte</span>[] size = ByteParser.shortToBytes((<span class="type">short</span>)data.length);</span><br><span class="line">       <span class="keyword">return</span> Bytes.concat(valid, size, data);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 构建DataItem</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> DataItem <span class="title function_">buildDataItem</span><span class="params">(Page page, <span class="type">short</span> offset, DataManager dm)</span>&#123;</span><br><span class="line">       <span class="type">byte</span>[] rawData = page.getPageData();</span><br><span class="line">       <span class="comment">// 注意这里是获取DataARecord中的DataSize</span></span><br><span class="line">       <span class="type">byte</span>[] dataItemDataSizeBytes = Arrays.copyOfRange(rawData, offset + DataItemSetting.DATA_SIZE_OFFSET, offset + DataItemSetting.DATA_DATA_OFFSET);</span><br><span class="line">       <span class="type">short</span> <span class="variable">dataItemDataSize</span> <span class="operator">=</span> ByteParser.parseBytesToShort(dataItemDataSizeBytes);</span><br><span class="line">       <span class="comment">// 得到整个DataRecord的大小</span></span><br><span class="line">       <span class="type">short</span> <span class="variable">dataRecordLength</span> <span class="operator">=</span> (<span class="type">short</span>)(DataItemSetting.DATA_DATA_OFFSET + dataItemDataSize);</span><br><span class="line">       <span class="type">long</span> <span class="variable">uid</span> <span class="operator">=</span> Logger.parsePageNumberAndOffsetToUid(page.getPageNumber(), offset);</span><br><span class="line">       <span class="comment">// 转换成SubArray的形式进行构建DataItem</span></span><br><span class="line">       <span class="type">SubArray</span> <span class="variable">dataRecord</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SubArray</span>(rawData, offset, offset + dataRecordLength);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataItemImpl</span>(dataRecord, <span class="keyword">new</span> <span class="title class_">byte</span>[dataRecordLength], page, uid, dm);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 设置DataRecord为无效</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setDataRecordInvalid</span><span class="params">(<span class="type">byte</span>[] dataRecord)</span>&#123;</span><br><span class="line">       dataRecord[DataItemSetting.DATA_VALID_OFFSET] = DataItemSetting.DATA_INVALID;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>上层模块需要对<code>DataItem进行修改</code>操作时，需要先调用<code>beforeModify()方法</code>，然后修改数据，最后调用<code>afterModify()方法</code>将记录写入日志；如果要撤销修改，就调用<code>unBeforeModify()方法</code>，将备份数据拷回</p><p>另外，与之相关的缓存键是由页号和偏移量组成的<code>8 字节无符号整数</code></p><h3 id="VersionManager-版本控制模块">VersionManager 版本控制模块</h3><ul><li><input type="checkbox" id="checkbox2"><label for="checkbox2">这里被拷打的几率很大，并发控制，调度序列，事务隔离级别</label></li></ul><p><code>VM模块</code>是事务额数据版本的管理核心</p><p><strong>实现MVCC多版本并发控制</strong><br><code>DM</code>向外提供<code>DataItem</code>，而<code>VM</code>通过管理所有数据项，向上层提供记录，上层模块操作数据的最小单位就是记录，然后<code>VM</code>在内部为每个记录维护了多个版本，每当上层模块对某个记录进行修改时，<code>VM</code>就会为这个记录创建一个新版本</p><p><strong>采用两段锁协议2PL实现调度序列的可串行化</strong>，同时利用MVCC降低事务阻塞概率</p><p><strong>实现事务隔离级别的读已提交和可重复读</strong></p><h4 id="事务抽象">事务抽象</h4><p>针对事务操作，实现一个事务类</p><h5 id="成员变量">成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象事务的XID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">long</span> xid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事务隔离级别</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> transactionIsolationLevel;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前事务执行(开始)时的活跃事务XID快照集合</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Long&gt; snapshotXIDsForActiveTransaction;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 意外终止标志，后续出现问题，这个成员变量会被设置为true，表示事务选择中止</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> accidentalTermination;</span><br></pre></td></tr></table></figure><p><code>snapshotXIDsForActiveTransaction</code>是专门用以记录某个事务执行时活跃的<code>事务xid</code>，方便可重复读级别下进行判断某个事务是否在当前事务的快照中</p><p>同时还有一个事务意外终止判断，如果发生意外终止就将此成员变量设为<code>true</code></p><h4 id="记录Record">记录Record</h4><p>这个类用以维护记录结构，且一个这个对象只有一个版本，一条记录存储在<code>一个DataItem</code>中</p><h5 id="结构">结构</h5><p>[XMIN][XMAX][Data]</p><ul><li><code>XMIN</code>表示的是创建这个记录的<code>事务XID</code>,也就是在此事务之后的事务才有可能拿到这个记录</li><li><code>XMAX</code>表示的是删除这个记录的<code>事务XID</code>,也就是在此事务之前的事务才有可能拿到这个记录,前两者都是<code>8字节long</code></li><li><code>Data</code>是这个事务持有的数据</li></ul><h5 id="逻辑操作">逻辑操作</h5><ol><li>数据读取时，需要获取读锁</li><li>修改数据<code>XMAX</code>时，需要调用<code>DataItem</code>的方法</li></ol><p>这里只有一个构建方法，用以根据<code>xid</code>和<code>data</code>包裹成一个<code>Record字节数组</code>数据，然后就是<code>设置XMAX方法</code>，<code>data数据修改逻辑</code>交给<code>TBM</code>管理</p><h4 id="事务可见性判断">事务可见性判断</h4><p>这里有一个类<code>VisibilityJudge</code>实现了针对读已提交和可重复读的事务可见性判读</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 针对特定事务隔离级别，判断记录对事务是否可见</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeVisibility</span><span class="params">(TransactionManager tm, Transaction transaction, Record record)</span> <span class="keyword">throws</span> WarningException, ErrorException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">transactionXid</span> <span class="operator">=</span> transaction.getXid();</span><br><span class="line">    <span class="type">long</span> <span class="variable">recordXmin</span> <span class="operator">=</span> record.getXMIN();</span><br><span class="line">    <span class="type">long</span> <span class="variable">recordXmax</span> <span class="operator">=</span> record.getXMAX();</span><br><span class="line">    <span class="comment">// 记录由当前事务创建且未被删除，可见</span></span><br><span class="line">    <span class="keyword">if</span>(transactionXid == recordXmin &amp;&amp; recordXmax == VMSetting.RECORD_XMAX_DEFAULT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (transaction.getTransactionIsolationLevel())&#123;</span><br><span class="line">        <span class="keyword">case</span> VMSetting.TRANSACTION_ISOLATION_LEVEL_READ_COMMITTED:</span><br><span class="line">            <span class="keyword">return</span> judgeForReadCommitted(tm, recordXmin, recordXmax);</span><br><span class="line">        <span class="keyword">case</span> VMSetting.TRANSACTION_ISOLATION_LEVEL_REPEATABLE_READ:</span><br><span class="line">            <span class="keyword">return</span> judgeForRepeatableRead(tm, transaction, recordXmin, recordXmax);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            Log.logWarningMessage(WarningMessage.TRANSACTION_ISOLATION_LEVEL_UNKNOWN);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 读已提交级别判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeForReadCommitted</span><span class="params">(TransactionManager tm, <span class="type">long</span> recordXmin, <span class="type">long</span> recordXmax)</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">    <span class="comment">// 如果记录由某个已经提交的事务创建</span></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(recordXmax))&#123;</span><br><span class="line">        <span class="comment">// 如果还未被删除，则可见</span></span><br><span class="line">        <span class="keyword">if</span>(recordXmax == VMSetting.RECORD_XMAX_DEFAULT)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果记录已被删除，则判断删除事务是否已经提交</span></span><br><span class="line">        <span class="comment">// 未提交则可见， 已提交则不可见</span></span><br><span class="line">        <span class="keyword">if</span>(recordXmax != recordXmin)&#123;</span><br><span class="line">            <span class="keyword">return</span> ! tm.isCommitted(recordXmax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 重复读级别判断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeForRepeatableRead</span><span class="params">(TransactionManager tm, Transaction transaction, <span class="type">long</span> recordXmin, <span class="type">long</span> recordXmax)</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">transactionXid</span> <span class="operator">=</span> transaction.getXid();</span><br><span class="line">    <span class="comment">// 如果记录由某个已经提交的事务创建，且该事务在当前事务执行之前提交</span></span><br><span class="line">    <span class="keyword">if</span>(tm.isCommitted(recordXmin) &amp;&amp; (recordXmin &lt; transactionXid &amp;&amp; !transaction.isInSnapshot(recordXmin)))&#123;</span><br><span class="line">        <span class="comment">// 未被删除，可见</span></span><br><span class="line">        <span class="keyword">if</span>(recordXmax == VMSetting.RECORD_XMAX_DEFAULT)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 被删除，则判断删除事务是否已经提交，或者在当前事务执行之后执行/提交</span></span><br><span class="line">        <span class="keyword">if</span>(recordXmax != recordXmin)&#123;</span><br><span class="line">            <span class="keyword">return</span> ! tm.isCommitted(recordXmax) || recordXmax &gt; transactionXid || transaction.isInSnapshot(recordXmax);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他情况不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读已提交的问题： 不可重复读和幻读</p><blockquote><p>不可重复读（Non-repeatable Read）：<br>发生在同一个事务内，当事务在不同时间点读取相同数据时，由于其他事务对数据的更新（修改或删除），导致事务内部的两次读取结果不一致。<br>例子：假设事务A读取一行记录，然后事务B更新了该记录并提交，事务A再次读取同一行时，会发现数据已被修改，尽管事务A自己没有进行任何写操作。</p><p>幻读（Phantom Read）：<br>也是在同一个事务内，当事务执行两次相同的查询（比如范围查询），由于其他事务在两次查询之间插入了新的记录，使得第二次查询的结果包含了第一次查询时不存在的记录。<br>例子：事务A首次执行一个区间查询，得到一定范围内的记录。随后，事务B在该范围内插入新的记录并提交，事务A再次执行相同的查询，会发现新的记录出现在结果集中，仿佛是“幻影”般突然出现。</p><p>不可重复读关注的是数据行本身的修改，即数据值的变更，而幻读关注的是数据集的完整性，即在查询范围内行数的增减</p></blockquote><p>在此基础上，可重复读需要忽略：在当前事务之后开始的事务数据、本事务开始时还是<code>active状态</code>事务的数据</p><p>版本跳跃问题：事务读取数据时跳过了某些版本，实际上问题不是很大，中间事务的修改看不到了而已，最终保存的是最后事务的提交结果<br>读已提交允许版本跳跃，可重复读不允许<br>解决版本跳跃： 如果当前<code>事务Ti</code>需要修改某个<code>数据X</code>，但是<code>X</code>已经被当前<code>事务Tj</code>不可见的事务修改，那么就要求<code>Tj</code>回滚。至于不可见的条件，就是<code>Tj</code>在<code>Ti</code>之后执行且已提交或者<code>Tj</code>在<code>Ti</code>的快照中（<code>Ti</code>开始时<code>Tj</code>活跃）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 判断记录是否出现版本跳跃</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judgeVersionHopping</span><span class="params">(TransactionManager tm, Transaction transaction, Record record)</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">      <span class="keyword">if</span>(transaction.getTransactionIsolationLevel() == VMSetting.TRANSACTION_ISOLATION_LEVEL_READ_COMMITTED)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">long</span> <span class="variable">recordXmax</span> <span class="operator">=</span> record.getXMAX();</span><br><span class="line">      <span class="keyword">return</span> tm.isCommitted(recordXmax) &amp;&amp; (recordXmax &gt; transaction.getXid() || transaction.isInSnapshot(recordXmax));</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="死锁检测">死锁检测</h4><p>因为<code>2PL</code>会阻塞事务，直到持有锁的线程释放锁。为了检测死锁，可以将锁的等待关系抽象成有向边，查看这个图中是否存在环</p><h5 id="VersionLockManager">VersionLockManager</h5><p>这里实现了一个<code>VersionLockManager</code>类，用以在内存中维护图<br>每次出现等待时，就尝试向图中增加一条边，并进行死锁检测，如果检测死锁就撤销这条边，不允许添加，并撤销事务</p><h6 id="成员变量-2">成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 某个XID事务已经控制的Record记录列表， 一个XID事务可以控制多个Record记录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, List&lt;Long&gt;&gt; transactionControlledRecords;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 某个Record记录被哪个XID事务持有，一个Record记录只能被一个XID事务持有</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Long&gt; recordControlledByTransaction;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 等待获取某个Record记录的XID事务列表，一个Record记录可以被多个XID事务等待</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, List&lt;Long&gt;&gt; recordWaitByTransactions;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 某个XID事务，在等待获取目标Record记录， 一个XID事务只能等待一个Record记录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Long&gt; transactionWaitForRecord;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 正在等待资源的XID事务，携带锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Lock&gt; transactionWaitWithLock;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 内部进程资源锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Lock selfLock;</span><br></pre></td></tr></table></figure><h6 id="逻辑设计">逻辑设计</h6><p>此类中有一个方法，尝试获取记录资源，如果资源没有被任何事务持久则在成员变量表中注册一下，返回<code>null</code>；如果已经被持有，将当前<code>事务xid</code>放入一个等待队列中，返回一个<code>ReentrantLock锁</code></p><p>死锁检测方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 死锁检测</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">detectDeadlock</span><span class="params">()</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">      <span class="built_in">this</span>.transactionStamp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">      <span class="built_in">this</span>.stampMark = VMSetting.VERSION_LOCK_DEADLOCK_DETECT_RING_STAMP_DEFAULT;</span><br><span class="line">      <span class="comment">// 从已经获取资源的事务中寻找</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">long</span> transactionXid : <span class="built_in">this</span>.transactionControlledRecords.keySet())&#123;</span><br><span class="line">          <span class="comment">// 当前事务戳</span></span><br><span class="line">          <span class="type">Integer</span> <span class="variable">xidStamp</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionStamp.get(transactionXid);</span><br><span class="line">          <span class="comment">// 该事务已经被标记过，跳过检测</span></span><br><span class="line">          <span class="keyword">if</span>(Objects.nonNull(xidStamp) &amp;&amp; xidStamp &gt; VMSetting.VERSION_LOCK_DEADLOCK_DETECT_RING_STAMP_DEFAULT)&#123;</span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 自增，dfs测环</span></span><br><span class="line">          <span class="built_in">this</span>.stampMark ++;</span><br><span class="line">          <span class="keyword">if</span>(<span class="built_in">this</span>.deepFirstSearchForDeadLock(transactionXid))&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 深度优先搜索检测死锁</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">deepFirstSearchForDeadLock</span><span class="params">(<span class="type">long</span> searchXid)</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">searchXidStamp</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionStamp.get(searchXid);</span><br><span class="line">      <span class="comment">// 存在环，有死锁</span></span><br><span class="line">      <span class="keyword">if</span>(Objects.nonNull(searchXidStamp) &amp;&amp; searchXidStamp == <span class="built_in">this</span>.stampMark)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 已经被检查，且不在当前检查路径中</span></span><br><span class="line">      <span class="keyword">if</span>(Objects.nonNull(searchXidStamp) &amp;&amp; searchXidStamp &lt; <span class="built_in">this</span>.stampMark)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 标记事务戳</span></span><br><span class="line">      <span class="built_in">this</span>.transactionStamp.put(searchXid, <span class="built_in">this</span>.stampMark);</span><br><span class="line">      <span class="type">Long</span> <span class="variable">waitingRecordUid</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionWaitForRecord.get(searchXid);</span><br><span class="line">      <span class="comment">// 看当前事务有没有正在等待的Record记录</span></span><br><span class="line">      <span class="keyword">if</span>(Objects.isNull(waitingRecordUid))&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 向上定位资源(相当于有向图的一条边指向后继节点)</span></span><br><span class="line">      <span class="type">Long</span> <span class="variable">tarRecordControlledTransactionXid</span> <span class="operator">=</span> recordControlledByTransaction.get(waitingRecordUid);</span><br><span class="line">      <span class="keyword">if</span>(Objects.isNull(tarRecordControlledTransactionXid))&#123;</span><br><span class="line">          Log.logErrorMessage(ErrorMessage.VERSION_CONTROL_RESOURCE_ERROR);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 看获取目标记录的事务是否会造成死锁</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.deepFirstSearchForDeadLock(tarRecordControlledTransactionXid);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>有环的话就会回到某个节点，访问到戳</p><p>另外，有一个方法用以释放资源锁，当某个事务提交或者撤销后，就可以释放其持有的锁，并在图中注销</p><p>同时，还有一个方法用以选择某个方法来获取被释放的资源，按等待的顺序即<code>FIFO</code>来选择事务持有这个资源</p><h4 id="VM对外提供接口">VM对外提供接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 事务开始</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">long</span> <span class="title function_">begin</span><span class="params">(<span class="type">int</span> transactionIsolationLevel)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 读取记录中的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">byte</span>[] read(<span class="type">long</span> xid, <span class="type">long</span> uid) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 插入记录数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">long</span> <span class="title function_">insert</span><span class="params">(<span class="type">long</span> xid, <span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 删除记录</span></span><br><span class="line"><span class="comment">   * 实现的是将记录的XMAX设置为当前事务XID,这样后续事务就无法读取到这条记录</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="type">long</span> xid, <span class="type">long</span> uid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 事务提交</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@Description</span>: 事务撤销</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">abort</span><span class="params">(<span class="type">long</span> xid)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> VersionManagerImpl <span class="title function_">buildVersionManager</span><span class="params">(TransactionManager tm, DataManager dm)</span> <span class="keyword">throws</span> ErrorException &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">VersionManagerImpl</span>(tm, dm);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="实现类">实现类</h4><p>这个实现类同时实现了<code>Record的缓存</code></p><h5 id="成员变量-3">成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TransactionManager tm;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> DataManager dm;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 档期那活跃的事务快照</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Long, Transaction&gt; activeTransactions;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> VersionLockManager vlm;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Lock selfLock;</span><br></pre></td></tr></table></figure><h5 id="逻辑操作-2">逻辑操作</h5><ol><li><code>begin事务开始</code><br>创建一个新事务，然后将事务xid返回，同时在活跃事务表中进行注册</li><li><code>read读数据</code><br>先根据xid拿到事务，再调用缓存方法拿到Record，如果检测事务可见性通过就返回数据，最后释放缓存资源引用</li><li><code>insert插入数据</code><br>直接将需要插入的数据包装为Record的字节数组形式，并利用DM持久化</li><li><code>delete删除记录</code><br>拿到事务后检测事务可见性，再使用<code>VersionLockManager</code>进行资源获取尝试，再检测是否发生版本跳跃，再将目标记录的<code>XMAX</code>设置为当前<code>事务xid</code></li><li><code>commit提交事务</code><br>拿到事务后，将活跃快照表中的数据删掉，再调用<code>VersionLockManager</code>进行资源释放，再调用<code>TM</code>提交事务持久化</li><li><code>abort撤销事务</code><br>拿到事务后调用<code>VersionLockManager</code>进行资源释放，再调用<code>TM</code>撤销事务持久化</li></ol><p>之所以撤销事务比较容易，是因为对于其他事务而言，只能看到处于已提交状态的事务所产生的数据，撤销后的事务不会对其他事务产生影响</p><h3 id="IndexManager-索引管理">IndexManager 索引管理</h3><p>提供基于<code>B+树</code>的聚簇索引，索引数据直接插入数据库文件，而不需要经过版本管理</p><h4 id="B-树节点">B+树节点</h4><p>这里是有一个类<code>BPlusTreeNode</code>实现了<code>B+树节点</code></p><h5 id="结构-2">结构</h5><ol><li>NodeHead: [LeafFlag][KeysCount][SiblingUID]<ul><li><code>LeafFlag</code> <code>byte类型</code>，标识当前节点是否是叶子节点</li><li><code>KeyCount</code> <code>short类型</code>，标识当前节点的关键字数量</li><li><code>SiblingUID</code> <code>long类型</code>，标识当前节点的<code>兄弟节点UID</code></li></ul></li><li>NodeBody: [SonNode0Uid][Key0][SonNode1Uid]…[SonNodeNUid][KeyN]</li></ol><ul><li><code>SonNodeUid</code>子节点<code>Uid</code>(唯一标识)</li><li><code>Key</code> 索引关键字</li></ul><p><strong>注意</strong>：</p><ul><li>在叶子节点中<code>uid</code>和<code>key</code>一一对应，存储的就是底层数据</li><li>而在非叶子节点中，<code>uid0</code>是没有配对值的，因为默认其左侧是无限小，<code>key0</code>是和<code>uid1</code>配对的， 是<code>uid1</code>子节点中的最小数据，而<code>keyN</code>是<code>MAX_VALUE无限大</code>，以方便查找</li><li>每个<code>Node</code>都存储在一条<code>DataItem</code>中</li><li>这里和<code>Mysql</code>中的索引结构是有区别的，<code>innodb引擎</code>中的节点之间使用的是双向链表，可以比较方便的从后往前进行范围查询</li></ul><h5 id="成员变量-4">成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 存放一个B+树的引用，方便使用dm</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> BPlusTree bPlusTree;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 方便管理数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> DataItem dataItem;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 节点数据</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> SubArray nodeData;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前节点的唯一标识uid</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="type">long</span> nodeUid;</span><br></pre></td></tr></table></figure><h5 id="实现逻辑-2">实现逻辑</h5><p>配置类中设置有一个平衡因子，当节点的子节点数量达到平衡因子的两倍时，进行分裂</p><p>所以新建一个节点时，会直接申请完整的所需空间<code>NODE_SIZE = NODE_HEAD_SIZE + NODE_SON_COUPLE_SIZE * (NODE_BALANCE_NUMBER + 1) * 2;</code></p><h6 id="新建节点">新建节点</h6><p>提供新建根节点和叶子节点的字节数组形式方法</p><ul><li>根节点放入左右子节点的<code>uid</code>，同时设置叶子标志为<code>false</code>，以及节点数量为<code>2</code></li><li>叶子节点设置叶子标志为<code>true</code>，节点数量为<code>0</code></li></ul><h6 id="查找">查找</h6><ol><li>精确查找<br>参数是一个<code>Key</code>，表示目标值，这是实现的是遍历查找（也能改成二分）<ul><li>如果在这一层找到了，就返回下一层的<code>uid值</code>，非叶子节点就返回下一层节点；叶子节点就是返回实际存储数据位置的持久层位置</li><li>如果没有找到，就返回兄弟节点<code>uid</code>，让调用方可以切到右边去找</li></ul></li><li>范围查找<br>参数是两个边界值，直接下到节点中去，先定位到大于等于<code>leftKey</code>的位置，然后往右走拿到后续符合条件的<code>uid</code><ul><li>如果这个节点还没走完就超出了右边界就返回</li><li>反之就同时返回兄弟节点<code>uid</code></li></ul></li></ol><h6 id="插入">插入</h6><p>参数是插入的<code>uid</code>和<code>key</code></p><ul><li>先找到第一个 <code>&gt;=</code> <code>key</code> 的位置，如果没找到而且当前节点有兄弟节点就切到兄弟节点去插</li><li>如果没有找到且没有兄弟节点，或者是找到了，就在当前节点中插入</li></ul><ol><li>如果插入的节点是叶子节点，直接将<code>uid</code>和<code>key</code>插入即可</li><li>如果插入的是非叶子节点，因为其<code>uid</code>和<code>key</code>不是对应关系，所以是将<code>kth</code>位置的<code>key</code>和<code>kth + 1</code>位置<code>uid</code>数据覆盖</li></ol><p>插入之后，会立即判断是否需要分裂，如果节点数达到<code>2 * 平衡因子</code>就进行分裂</p><h6 id="分裂">分裂</h6><p>逻辑也比较好理解：</p><ol><li>创建新节点</li><li>复制当前节点的叶子/非叶子属性、兄弟节点信息给新节点</li><li>将新节点的子节点数量设置为平衡因子</li><li>将右侧的半边数据分给新节点</li><li>将新节点持久化</li><li>更新当前节点的兄弟节点为新节点</li></ol><h4 id="B-树">B+树</h4><p>有一个<code>B+树</code>类，索引的数据直接被插入到数据库文件进行持久化，不经过版本管理</p><h5 id="成员变量-5">成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 数据管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> DataManager dm;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 用以对 rootUid 数据进行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> DataItem rootUidDataItem;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 自身资源锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Lock selfLock;</span><br></pre></td></tr></table></figure><h5 id="实现逻辑-3">实现逻辑</h5><h6 id="构建和加载B-树">构建和加载B+树</h6><p>初始构建时，创建一个叶子节点作为初始根节点，然后利用<code>DM</code>持久化，并拿到这个节点的标识<code>uid</code></p><p>加载<code>B+树</code>时，则利用DM从持久层拿到数据，然后包裹成<code>B+树</code>对象</p><h6 id="更新节点">更新节点</h6><p>这个方法用以更新一个节点为真正的根节点，构建一个字节数组形式的根节点之后持久化，并设置为根节点（也可以理解为非叶子节点）</p><h6 id="数据查找">数据查找</h6><ol><li>提供一个方法用以搜索下一层能够满足条件的节点<br>借助<code>B+树节点</code>类型实现，直接查找满足特定条件的节点</li><li>提供一个方法查找查找符合条件的叶子节点</li><li>提供方法在叶子节点中进行范围查找<br>也是借助<code>B+树节点</code>类实现</li></ol><h6 id="插入数据">插入数据</h6><p>暴露给外部模块以进行数据的插入</p><ul><li>如果插入位置是叶子节点，下到内部插入方法，借助<code>B+树节点</code>进行插入，然后直接返回结果</li><li>如果插入位置是非叶子节点，就还需要借助精确查找定位到下一层去，进行递归插入，如果插入完成了且发生分裂，还需要更新分裂节点的插入</li></ul><p>上面完成后返回插入结果，如果发生分裂，就需要更新根节点</p><p><strong>注意</strong>：可能需要进行多次节点分裂更新，所以这里比较绕</p><h3 id="StatementParser-语句解析模块">StatementParser 语句解析模块</h3><p>这个模块用以进行<code>SQL语句</code>的解析</p><h4 id="逻辑实现">逻辑实现</h4><h5 id="Tokenizer-分词器">Tokenizer 分词器</h5><p>这个类用以将文本分割为一些最小单位的<code>token</code></p><h6 id="成员变量-6">成员变量</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 语句</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] statement;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前在语句中的分析定位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> curAnalysisPos;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 当前解析出的token</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> String curToken;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否需要刷新token,即将下一个token解析出来</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="type">boolean</span> needFlushToken;</span><br></pre></td></tr></table></figure><h6 id="实现方法">实现方法</h6><ul><li><code>Tokenizer(byte[] statement)</code>：<br>构造函数，接收一个字节数组作为需要分割的语句，并初始化相关成员变量</li><li><code>String peek() throws WarningException</code>：<br>获取当前解析出的<code>token</code>，如果需要刷新<code>token</code>，则先解析下一个<code>token</code></li><li><code>void pop()</code>：<br>强制要求刷新<code>token</code>，即将<code>下一个token</code>解析出来</li><li><code>String nextMetaState() throws WarningException</code>：<br>解析下一个<code>token</code>，具体实现根据不同的字符类型进行处理</li><li><code>String nextQuoteState() throws WarningException</code>：<br>处理引号包含的<code>toke</code></li><li><code>String nextTokenState()</code>：<br>处理只含字母、数字、下划线的<code>token</code></li><li><code>Byte peekByte()</code>：<br>获取当前分析位置的字符</li><li><code>void popByte()</code>：<br>将当前分析位置向后移动一位</li><li><code>String StateAnalysisWrong() throws WarningException</code>：<br>处理解析错误的情况</li><li><code>byte[] getStatement()</code>：<br>获取完整的解析语句</li></ul><p>此类的分词方法结合字符串配置类实现</p><h5 id="StatementParser-语句解析器">StatementParser 语句解析器</h5><p>借助分词器，逐步解析语句，并返回相应的解析结果类，用以供上层模块使用，其中还包含解析<code>where语句</code>，但是比较简陋</p><p>这里的判断是写死的，所以如果改动的话会比较麻烦，正规的做法应该是使用语法树</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># begin事务开始语句，设置事务隔离级别</span><br><span class="line">begin [isolation level] [read committed | repeatable read]</span><br><span class="line"></span><br><span class="line"># commit事务提交语句</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line"># abort事务回滚语句</span><br><span class="line">abort</span><br><span class="line"></span><br><span class="line"># create table 建表语句，指定字段和索引</span><br><span class="line">create table [tableName]</span><br><span class="line">             [fieldName1][fieldType1],</span><br><span class="line">             ...</span><br><span class="line">             [fieldNameN][fieldTypeN]</span><br><span class="line">             (index [indexName1]...[indexNameM])</span><br><span class="line"></span><br><span class="line"># drop table 删除表语句</span><br><span class="line">drop table [tableName]</span><br><span class="line"></span><br><span class="line"># select 查询语句,  where语句是可选的</span><br><span class="line">select * | [fieldName1], [fieldName2], ...</span><br><span class="line">      from [tableName]</span><br><span class="line">      where ...</span><br><span class="line"></span><br><span class="line"># insert 插入语句</span><br><span class="line">insert into [tableName] values [value1], [value2], ...</span><br><span class="line"></span><br><span class="line"># delete 删除语句</span><br><span class="line">delete from [tableName] where ...</span><br><span class="line"></span><br><span class="line"># update 更新语句</span><br><span class="line">update [tableName] set [fieldName] = [value] where ...</span><br></pre></td></tr></table></figure><h3 id="TableManager-表管理模块">TableManager 表管理模块</h3><p>这个模块实现的是表、字段管理，当上层模块调用语法解析器解析出结果后面，就会调用这个模块进行表的创建、数据修改</p><p>表结构实现的是在用一个数据库/架构下的表使用链表的形式进行串联</p><h4 id="提供接口-3">提供接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 开启事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TBMSetting.BeginResult <span class="title function_">begin</span><span class="params">(SPSetting.Begin begin)</span> <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 提交事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] commit(<span class="type">long</span> xid) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 撤销事务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] abort(<span class="type">long</span> xid) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 创建表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] create(<span class="type">long</span> xid, SPSetting.Create create) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 插入数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] insert(<span class="type">long</span> xid, SPSetting.Insert insert) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] drop(<span class="type">long</span> xid, SPSetting.Drop drop) <span class="keyword">throws</span> WarningException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 查询数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] select(<span class="type">long</span> xid, SPSetting.Select select) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 删除数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] delete(<span class="type">long</span> xid, SPSetting.Delete delete) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 更新数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">byte</span>[] update(<span class="type">long</span> xid, SPSetting.Update update) <span class="keyword">throws</span> WarningException, ErrorException;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="逻辑实现-2">逻辑实现</h4><h5 id="Field-表字段实体类">Field 表字段实体类</h5><p>此类是表字段的模型，记录有<code>字段的uid</code>唯一标识，字段类型，<code>索引uid</code>，同时成员变量中有一个字段索引关联的B+树</p><p>持久化时会调用<code>DM</code>写入数据，同时提供取出数据转化为本类的方法</p><h5 id="Table实体类">Table实体类</h5><p>这个类是表的模型，存储有<code>当前表的uid</code>，<code>下一个表的uid</code>，以及该表字段列表，同样持久化时也是调用<code>DM</code>写入，实现字节数据解析为当前类方法</p><p><code>TBM</code>实现的表数据管理部分就是基于这个实体类在做，调用这个类的<code>Insert</code>、<code>Update</code>、<code>Select</code>方法</p><h5 id="Booter启动类">Booter启动类</h5><p>这个类时表管理器的启动类，存储有第一张表（头表）的信息，更新此文件时会先创建一个临时文件再替换为实际文件</p><h5 id="TableManager-实现">TableManager 实现</h5><p>提供创建方法和打开方法，分别用以创建启动类和打开启动类文件拿到表信息</p><p>实现类中包含表缓存信息，以及针对某个事务的一系列表缓存，一开始就会将表信息放入缓存中</p><p>创建表也会放入缓存，修改表会进行相应持久化，删除表则会将缓存中数据删除，持久层不用删</p><h3 id="传输模块">传输模块</h3><p>这个模块用以在创建的Socket基础上进行数据传输</p><h4 id="自定义数据包">自定义数据包</h4><p>这里自定义了一个数据包实现类，成员变量是一个字节数组和一个异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始数据</span></span><br><span class="line">   <span class="type">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 异常信息</span></span><br><span class="line">   Exception exception;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">DataPackage</span><span class="params">(<span class="type">byte</span>[] data, Exception exception)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.data = data;</span><br><span class="line">       <span class="built_in">this</span>.exception = exception;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="type">byte</span>[] getData() &#123;</span><br><span class="line">       <span class="keyword">return</span> data;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> Exception <span class="title function_">getException</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> exception;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="编解码器">编解码器</h4><p>通信数据使用的是二进制，这个编解码器负责将自定义数据包和字节数组之间的相互转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 数据编码，将数据包转换成字节数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] dataEncode(DataPackage dataPackage)&#123;</span><br><span class="line">       <span class="type">Exception</span> <span class="variable">dataException</span> <span class="operator">=</span> dataPackage.getException();</span><br><span class="line">       <span class="keyword">if</span>(Objects.nonNull(dataException))&#123;</span><br><span class="line">           <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;TransportSetting.DATA_IS_EXCEPTION_TRUE&#125;, dataException.getMessage().getBytes());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> Bytes.concat(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;TransportSetting.DATA_IS_EXCEPTION_FALSE&#125;, dataPackage.getData());</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Author</span>: 711lxsky</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@Description</span>: 数据解码，将字节数组转换成数据包</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> DataPackage <span class="title function_">dataDecode</span><span class="params">(<span class="type">byte</span>[] data)</span> <span class="keyword">throws</span> WarningException &#123;</span><br><span class="line">       <span class="keyword">if</span>(data.length &lt; TransportSetting.DATA_MIN_LENGTH_DEFAULT)&#123;</span><br><span class="line">           Log.logWarningMessage(WarningMessage.DATA_ERROR);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 正常数据</span></span><br><span class="line">       <span class="keyword">if</span>(data[<span class="number">0</span>] == TransportSetting.DATA_IS_EXCEPTION_FALSE)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataPackage</span>(Arrays.copyOfRange(data, TransportSetting.DATA_EXCEPTION_MARK_OFFSET, data.length), <span class="literal">null</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 异常信息</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(data[<span class="number">0</span>] == TransportSetting.DATA_IS_EXCEPTION_TRUE)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DataPackage</span>(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="keyword">new</span> <span class="title class_">String</span>(Arrays.copyOfRange(data, TransportSetting.DATA_EXCEPTION_MARK_OFFSET, data.length))));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           Log.logWarningMessage(WarningMessage.DATA_ERROR);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>编码时，会根据是有异常，如果有异常就将异常信息放到字节数组中发出，并设置一个校验位；解码时，根据校验位来判断是将二进制数据转换为data还是异常</p><h4 id="Transporter-传输器">Transporter 传输器</h4><p>传输器实现类基于<code>socket</code>，先构建获取自<code>socket</code>读流、写流</p><p>同时提供方法实现十六进制数据和字节数组之间的互相转换</p><p>写时，将字节数据转换为十六进制数据<br>读时，将十六进制数据转换为字节数据</p><h4 id="向外提供-Packager-数据包装传输器">向外提供 Packager 数据包装传输器</h4><p>暴露一个<code>Packager类</code>，以传输器为成员变量，提供发送数据、接受数据方法</p><h3 id="服务端">服务端</h3><h4 id="Server类">Server类</h4><p><code>Server类</code>中以<code>TBM</code>和一个<code>int</code>类型的端口为成员变量，只有一个启动方法，先尝试创建一个监听特定端口的<code>ServerSocket</code>，然后构建一个线程池，之后进入一个<code>true</code>条件的<code>while循环</code>，不断接收客户端的连接请求，对每个连接进行处理，然后创建一个<code>SocketHandler</code>处理器，传入<code>tbm</code>和<code>socket</code>连接，并交给之前构建的线程池去执行</p><h4 id="SocketHandler-处理器">SocketHandler 处理器</h4><p>这个类继承了<code>Runnable</code>，算是一个线程类，先打印和客户端的连接信息，然后创建一个传输模块提供的<code>Packager</code>，然后创建一个<code>Executor</code>执行器，利用<code>packager</code>接收客户端数据，再交给执行器执行<code>SQL语句</code>，得到结果后封装返回</p><h4 id="Executor-服务端SQL语句解析执行器">Executor 服务端SQL语句解析执行器</h4><p>这个类以<code>xid</code>和<code>tbm</code>为成员变量，调用<code>SP</code>模块静态方法解析<code>SQL语句</code>，然后根据返回的类型调用<code>tbm</code>做实际的数据操作</p><h4 id="Launcher-服务端启动类">Launcher 服务端启动类</h4><p>这个类用以进行服务端的启动，借助<code> org.apache.commons.cli</code>创建命令行交互，指导创建或者打开数据库，去调用<code>TM</code>、<code>DM</code>、<code>VM</code>、<code>TBM</code>模块方法，如果是打开数据库就会<code>启动Server</code>，准备监听客户端</p><h3 id="客户端">客户端</h3><h4 id="Client类">Client类</h4><p>以<code>Packager</code>为成员变量，实现有一个<code>execute</code>方法以进行数据的收发</p><h4 id="Shell-命令行类">Shell 命令行类</h4><p>以<code>Client</code>为成员变量，比较简陋地读取用户输入，然后调用<code>Client</code>以发送、拿到返回的数据，同时执行<code>Client</code>的<code>close</code>方法，关闭数据包</p><h4 id="Launcher-客户端启动类">Launcher 客户端启动类</h4><p>同样，客户端也有一个启动类，先创建一个<code>ClientSocket</code>，然后构建<code>Packager</code>，最后构建<code>Shell</code>，然后启动<code>Shell</code></p><h2 id="结语">结语</h2><p>整体来说项目难度还是不低的，比起业务上的设计我感觉更考验<code>Java</code>基础，而且项目整体设计和把握也需要一定的架构能力</p><p>哎哎，还是得继续撸码🤥</p>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux(2)</title>
      <link href="/2024/05/07/blog20/"/>
      <url>/2024/05/07/blog20/</url>
      
        <content type="html"><![CDATA[<h2 id="记录一次Manjaro系统的惊险修复">记录一次<code>Manjaro</code>系统的惊险修复</h2><h3 id="背景">背景</h3><p><s>这次真不是水</s></p><p>前几天五一假期中期之时， 因为跑一个<code>React</code>项目的缘故， 偶然间修改了根目录下<code>/usr</code>路径的权限。😇类似于:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod -R 777 /usr</span><br></pre></td></tr></table></figure><p>后续执行<code>sudo xxx</code>指令就报错<code>/usr/bin/sudo 必须属于用户 ID 0(的用户)并且设置 setuid 位</code>🤕</p><p>哎哎，自然是权限问题，因为<code>Linux</code>系统下的<code>sudo</code>权限必须交给<code>root</code>用户<br>(题外话说一下<code>setuid</code>, <code>setuid</code>位是一种特殊权限位，当设置在某个可执行文件上时，允许任何用户在执行该文件时拥有文件所有者的权限。对于<code>sudo</code>这样的命令，这是必要的，因为它允许非<code>root</code>用户临时提升权限执行管理任务)</p><p><code>现在</code>sudo`也用不了，不能把权限给赋回去，好吧，开始救命</p><h3 id="解决步骤">解决步骤</h3><h4 id="疯狂搜索"><s>疯狂</s>搜索</h4><p>用这个报错信息一查，结果发现不止我一个<s>傻春</s>😝</p><p>靠前的搜索结果说的是重启进安全/紧急/单人模式，然后手动把权限改回去；或者直接当前状态下切到<code>root</code>用户，but这个方案似乎并没有起作用，<code>su</code>之后输密码重复试了很多次都还是不行，猜测也是<code>/usr</code>的改动导致的</p><h4 id="问问拷打😎">问问<s>拷打</s>😎</h4><p>抱着死马当作活马医的想法，就跑过去问<code>GPT</code>，特别提一下，是模型<code>gpt-4-0125-preview</code>，(另外，感谢<a href="https://github.com/lhx-666-cool">@LHX</a>的维护, 让我能够长期免费使用到<code>GPT</code>)给出的解决方案和搜索结果类似 :</p><p><img src="/2024/05/07/blog20/gpt_ask1.jpg" class="lazyload" data-srcset="/2024/05/07/blog20/gpt_ask1.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GPT对话1"><br><img src="/2024/05/07/blog20/gpt_ask2.jpg" class="lazyload" data-srcset="/2024/05/07/blog20/gpt_ask2.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="GPT对话2"></p><p>当时电脑上浏览器开了不少窗口，同时又打算重启电脑，故用手机在问:)</p><h4 id="正式开始">正式开始</h4><h5 id="1-进入单人模式">1. 进入单人模式</h5><p>重启之后先进到<code>Majaro</code>启动的编辑界面(我这里是按<code>E</code>即进)， 然后定位到<code>Linux</code>开头那一行，加上<code>single init=/bin/bash</code>同时将<code>ro</code>改成<code>rw</code>， 以读写模式挂载</p><h5 id="2-指令修复">2. 指令修复</h5><p>这里先把几个系统分区挂上</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lsblk # 查看分区</span><br><span class="line">mount /dev/sda&#123;x&#125; /mnt # 挂载</span><br></pre></td></tr></table></figure><p>然后直接去修改权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown root:root /usr/bin/sudo</span><br><span class="line">chmod 4755 /usr/bin/sudo</span><br></pre></td></tr></table></figure><p>先修改文件目录所有者， 再该权限</p><p>解释<code>4755</code>:</p><blockquote><p>第一位（4）表示特殊权限中的SetUID位（SUID）。当应用于可执行文件时，SUID允许任何用户在执行该文件时，暂时拥有文件所有者的权限。这对于需要普通用户以root或其他特权用户权限执行某些操作的情况非常有用，例如/usr/bin/passwd命令允许用户更改密码，就是利用了SUID权限。<br>接下来的三位（7）表示文件所有者的权限，拥有读（r=4）、写（w=2）、执行（x=1）权限，合起来就是7（4+2+1），即rwx。<br>再接下来的三位（5）表示与文件所有者同组的用户的权限，拥有读（r=4）和执行（x=1）权限，没有写权限，即rx。<br>最后的三位（5）表示其他用户的权限，同样拥有读和执行权限，没有写权限。</p><p>总结来说，权限4755赋予了文件所有者全部权限，文件所属组用户和其他用户有读取和执行权限，并且由于设置了SUID位，任何用户执行该文件时都将暂时拥有文件所有者的权限。这种权限设置常见于需要提升权限执行的二进制程序上</p></blockquote><h5 id="3-重启测试">3. 重启测试</h5><p>重启之后<code>sudo</code>确实是好了，但是又出现了新问题😓</p><p>首先是<code>zsh</code>打开的时候就报错，大致意思是配置文件无法找到，补全失效</p><p>然后又有<code>AppImage</code>报错<code>You might still be able to extract the contents of this AppImage  if you run it with the --appimage-extract option.  See https://github.com/AppImage/AppImageKit/wiki/FUSE  for more information</code></p><p>同时网络驱动貌似也死了</p><h5 id="4-修复新问题">4. 修复新问题</h5><p>所以我就去先修<code>AppImage</code>，这个地方我尝试着把所有分区重新挂载一遍貌似好了</p><p>网络问题，就只能<code>USB</code>连线使用手机共享网络</p><p>然后修<code>zsh</code>，卸载之后重装，还是不行，我以为是环境变量设置未生效，就打算重启看看</p><p>好么，重启结果卡住了，😡卡在启动界面进不去了<s>卧槽</s>，就靠着<code>Ctrl+Alt+F3</code>切换到<code>tty</code>模式，刚进去就看到提示<code>No space left on device</code>，用<code>df -h</code>查看磁盘占用情况，就发现<code>/var</code>分区<code>20G</code>全部占满，再使用<code>sudo du -ahx /var | sort -rh | head -20</code>查看目录下占用内存最大的文件，就看到有个<code>/var/log/cups/error_log</code>文件，大概有10多G,查阅之后知道这个日志是通用<code>Unix</code>打印系统(<code>Common Unix Printing System</code>)产生的，应该没啥用，就直接删除，但是因为命令提示行之前设置的是能够打印中文，所以很多提示都是方形的空白字符，根本看不清，删了几次才成功</p><p>不少次尝试后成功进入系统，我想要试试<code>zsh</code>配置重新设置之后能否生效，使用<code>source ~/.zshrc</code>，结果报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">警告：目录权限不一致 </span><br><span class="line">/usr/bin/ 文件系统：777  软件包：755 </span><br><span class="line">警告：目录权限不一致 </span><br><span class="line">/usr/lib/ 文件系统：777  软件包：755 </span><br><span class="line">警告：目录权限不一致 </span><br><span class="line">/usr/lib/zsh/ 文件系统：777  软件包：755 </span><br><span class="line">警告：目录权限不一致 </span><br><span class="line">/usr/lib/zsh/5.9/ 文件系统：777  软件包：755 </span><br><span class="line">警告：目录权限不一致 </span><br><span class="line">/usr/lib/zsh/5.9/zsh/ ...</span><br></pre></td></tr></table></figure><p>突然想到<code>/usr</code>之前被我修改权限了，但是只改回了<code>/usr/bin/sudo</code>，所以就打算手动把其他目录改回来，结果一个不小心，又把<code>/usr/bin</code>目录改了<s>我是SB</s>🤡，导致又要进单人模式，所幸有了之前的经验，这次改的很快，重启之后去查有没有比较方便修复文件系统权限的命令，果然有：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yay -S pacman-fix-permissions</span><br><span class="line">sudo pacman-fix-permissions</span><br></pre></td></tr></table></figure><p>先装好<code>pacman-fix-permissions</code>，然后去执行命令修复权限<br>我看命令执行情况，貌似是分析本机应用依赖包，然后全局扫描，测试权限，再改回来，大概跑了半个小时，重启之后系统修复，完好如初！😀</p><h3 id="回顾总结">回顾总结</h3><p>还好自己没有直接想着重装，而是尝试去修复(毕竟也不想再重装配环境了)</p><p>下次别在手贱不过脑子直接改权限了！🥲</p><p>其实之前用<code>Linux</code>的时候，也出过不少问题，<br>先是在一台主机上装了<code>Ubuntu</code>，第一次问题是不小心使用<code>sudo rm -f /etc</code>(当时是删别的某个路径，结果新开一个命令行忘切目录)把核心配置全删了，啥指令都不起作用，当时打算从别人那儿把<code>/etv</code>拷过来，结果挂载不上去，<code>U盘</code>调不出来，重装！<br>再有，是这个重装的<code>Ubuntu</code>系统，因为默认装的<code>Gnome</code>图形界面，非常不稳定，经常应用卡退，换成<code>KDE</code>，就直接红屏了；没办法，先改回去<code>Gnome</code>，然后看有人说输入法可能会造成应用闪退，卸掉，没起作用；修显卡驱动，重启，卡死了，文件系统崩溃，网络驱动也寄了，全挂了，直接重装<code>Kubuntu</code>了(这个系统用的倒是还好，没啥问题)<br>笔记本上的<code>Manjaro</code>，之前有一次分区不合理，想要合并分区来着，结果出了无法修复的问题，也重装过一次。有一说一，<code>Manjaro</code>是我用的最舒服的，日常没啥问题</p><p>哎哎，下次出问题继续修，反正是折腾😆</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>借助SpringBoot实现异步调用</title>
      <link href="/2024/03/31/blog19/"/>
      <url>/2024/03/31/blog19/</url>
      
        <content type="html"><![CDATA[<h2 id="基于SpingBoot实现异步调用">基于<code>SpingBoot</code>实现异步调用</h2><h3 id="小水一下">小水一下</h3><p>😋哈，终于抓住3月的尾巴，更篇文章～～</p><p>来学校之后，把<code>Mysql</code>八股基本过了一遍，微服务又去熟悉了一下，还得边学计组计网操作系统(<s>天杀得jwc</s>反正迟早得学)。每天<code>leetcode</code>倒是坚持了下来，就是平常得应付学校不少破事儿，感觉精力越来越不及以前充沛了😢</p><p>最近在准备轮子项目，一个简易数据库(偷师某位来自<code>HIT</code>的学长)，支持读提交、可重复读事务隔离级别，包含页面索引，支持MVCC、2PL等等，目前差不多完成一半了，之后完成并且<s>测试通过</s>(这个flag还是不立了)之后，肯定会好好写篇文章<s>把注释搬出来</s>总结一下(哈<s>准备接受拷打</s>)原意是打算做<a href="https://pdos.csail.mit.edu/6.824/index.html">6.824(现6.5840)</a>，把分布式实践一下，但是不确定有没有连贯的精力，还得准备个微服务项目和八股，所以还是选择了写这个</p><h3 id="好了好了，回归正题">好了好了，回归正题</h3><p>对于异步调用，最开始听到是看<code>JUC</code>八股的时候；再后来在微服务中，某个模块向消息队列发送处理消息，处理模块接收消息处理，也是异步调用的思想。</p><p>上游的“我”这里只需要处理好我需要做的任务，剩下的交给下游“你”去完成，“我”只需要返回&quot;我&quot;的任务执行情况。这里的上下游可能是单机中的不同进程，也可以是不同服务器上的不同服务😎</p><p>正巧，hx从老师那里接了个需求很模糊的项目，需要调用后台服务执行一个<code>Python</code>脚本，这个脚本运行时间可能是几分钟～十多分钟。自然不能一直让前台等待执行结果，做一个<code>Websocket</code>感觉又比较大材小用，于是我就弄了个异步调用，将接收请求进程和运行脚本线程分开，前台只需要轮询查询执行情况即可。原本我还以为写起来比较麻烦，没想到写架子就花了不到一个小时，反而是层级解耦花了不少时间(<s>掌嘴</s>😤)</p><h3 id="具体实现">具体实现</h3><p>这里本就是借助<code>SpringBoot</code>实现，所以方便的很</p><h4 id="依赖">依赖</h4><p>先得有依赖(这里使用<code>Maven</code>，所以在<code>pom.xml</code>中加入)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>你的Spring Boot版本对应的版本号<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是这个依赖是<code>SpringBoot</code>的核心依赖之一，一般只要有<code>starter</code>就行了:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="线程池配置">线程池配置</h4><p>一般还需要配置一下异步调用线程池，针对服务挂载端的配置调整线程池、任务队列</p><p>贴一下我的写法(写在配置文件中，方便一键更改)：</p><p><code>application.properties</code>中：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ------异步线程池配置-------</span></span><br><span class="line"><span class="comment"># 线程池核心线程数</span></span><br><span class="line"><span class="attr">async-settings.corePoolSize</span>=<span class="string">2</span></span><br><span class="line"><span class="comment"># 线程池最大线程数</span></span><br><span class="line"><span class="attr">async-settings.maxPoolSize</span>=<span class="string">4</span></span><br><span class="line"><span class="comment"># 任务队列最大容量</span></span><br><span class="line"><span class="attr">async-settings.queueCapacity</span>=<span class="string">100</span></span><br><span class="line"><span class="comment"># 线程池线程名前缀</span></span><br><span class="line"><span class="attr">async-settings.thread-name-prefix</span>=<span class="string">Async-</span></span><br></pre></td></tr></table></figure><p>写个配置类(用了<code>lombok</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;async-settings&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncConfig</span> <span class="keyword">extends</span> <span class="title class_">AsyncConfigurerSupport</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> maxPoolSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> queueCapacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String threadNamePrefix;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Executor <span class="title function_">getAsyncExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">ThreadPoolTaskExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolTaskExecutor</span>();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maxPoolSize);</span><br><span class="line">        executor.setQueueCapacity(queueCapacity);</span><br><span class="line">        executor.setThreadNamePrefix(threadNamePrefix);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意注解<code>EnableAsync</code>表示启用异步调用</p><p>然后在需要异步调用执行的方法上加上<code>@Async</code>注解即可</p><p>一般我会把方法实现为返回值为<code>CompletableFuture</code>包裹泛型(<code>CompletableFuture&lt;T&gt; implements Future&lt;T&gt;, CompletionStage&lt;T&gt;</code>)，异步方法中发生的异常默认是不会被调用者捕获的。如果你的异步方法返回<code>Future</code>，那么异常将会被封装在<code>Future</code>中，你可以通过<code>Future.get()</code>方法来获取，另外获取执行结果也比较方便</p><h3 id="结语">结语</h3><p>哎哎，真方便真快啊</p><p>不过最近看到有个<code>Java</code>框架新秀<code>Solon</code>;<br><a href="https://github.com/noear/solon">Github地址</a><br><a href="https://gitee.com/noear/solon">Gitee</a><br>现在已经是<code>Gitee</code>的<code>GVP</code>项目了，看作者在官方群里说效率挺高，和<code>Gin</code>相差无几。之前看了下貌似确实挺轻的，之后好好看看</p><p>周末结束力，明天又是早八<s>点半</s>😇</p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的前中后序遍历Morris实现</title>
      <link href="/2024/02/10/blog18/"/>
      <url>/2024/02/10/blog18/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的Morris前中后序遍历">二叉树的Morris前中后序遍历</h2><h3 id="水水"><s>水水</s></h3><p>新年好捏🎆</p><p>24年的大年初一，终于更一下年前就打算弄的一个文章。<br>在力扣做<code>hot100</code>的时候，做到树的章节，开头就是二叉树的中序遍历实现，嘿，递归和正常非递归实现都好说，但是有个<code>Morris</code>方法，把空间复杂度降到<code>O(1)</code>，刚好很久之前做这题的时候也是一知半解，仔细一看和线索二叉树有关，所以打算好好看看</p><h3 id="先说说递归和一般非递归-迭代-遍历实现">先说说递归和一般非递归(迭代)遍历实现</h3><p>这俩本质上不差多少，都是用栈实现，只是一个是系统栈，一个是自定义的栈</p><p>先把树节点结构定义一下，基于<code>Go</code>书写，且定位为<code>LeetCode</code>原题:<br><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/description/">二叉树前序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">二叉树中序遍历</a><br><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/description/">二叉树后序遍历</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 存储值</span></span><br><span class="line">Val   <span class="type">int</span> </span><br><span class="line">    <span class="comment">// 左子节点</span></span><br><span class="line">Left  *TreeNode </span><br><span class="line">    <span class="comment">// 右子节点</span></span><br><span class="line">Right *TreeNode </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归实现">递归实现</h4><p>时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(n)</code>，使用系统栈</p><p>很好理解嘛，到达当前节点后，直接去到左右子节点，一直到叶子节点，再逐层调用返回</p><h5 id="前序遍历">前序遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> (vals []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> preorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    preorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">        preorder(node.Left)</span><br><span class="line">        preorder(node.Right)</span><br><span class="line">    &#125;</span><br><span class="line">    preorder(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历">中序遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">var</span> inorder <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span></span><br><span class="line">inorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">inorder(node.Left)</span><br><span class="line">res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">inorder(node.Right)</span><br><span class="line">&#125;</span><br><span class="line">inorder(root)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历">后序遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> postorder <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span></span><br><span class="line">    postorder = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        postorder(node.Left)</span><br><span class="line">        postorder(node.Right)</span><br><span class="line">        res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">    &#125;</span><br><span class="line">    postorder(root)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="非递归-迭代-实现">非递归(迭代)实现</h4><p>时间复杂度是<code>O(n)</code>，空间复杂度是<code>O(n)</code>，使用自定义栈</p><p>和递归一样，只是自己手动去控制栈，直接深入到叶子节点，然后再自底向上去走节点，逐层遍历完</p><h5 id="前序遍历-2">前序遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> (vals []<span class="type">int</span>) &#123;</span><br><span class="line">    stack := []*TreeNode&#123;&#125;</span><br><span class="line">    node := root</span><br><span class="line">    <span class="keyword">for</span> node != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">            vals = <span class="built_in">append</span>(vals, node.Val)</span><br><span class="line">            stack = <span class="built_in">append</span>(stack, node)</span><br><span class="line">            node = node.Left</span><br><span class="line">        &#125;</span><br><span class="line">        node = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>].Right</span><br><span class="line">        stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="中序遍历-2">中序遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">stack := []*TreeNode&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, root)</span><br><span class="line">root = root.Left</span><br><span class="line">&#125;</span><br><span class="line">root = stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="后序遍历-2">后序遍历</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line">    stk := []*TreeNode&#123;&#125;</span><br><span class="line">    <span class="keyword">var</span> prev *TreeNode</span><br><span class="line">    <span class="keyword">for</span> root != <span class="literal">nil</span> || <span class="built_in">len</span>(stk) &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line">            stk = <span class="built_in">append</span>(stk, root)</span><br><span class="line">            root = root.Left</span><br><span class="line">        &#125;</span><br><span class="line">        root = stk[<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">        stk = stk[:<span class="built_in">len</span>(stk)<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">if</span> root.Right == <span class="literal">nil</span> || root.Right == prev &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">            prev = root</span><br><span class="line">            root = <span class="literal">nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stk = <span class="built_in">append</span>(stk, root)</span><br><span class="line">            root = root.Right</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Morris遍历">Morris遍历</h3><p>好了，重头戏来了<br>其实这种方式是利用叶子节点的空指针，将某个父节点的中序遍历前驱节点的右指针指向父节点，使得遍历完左子树后得以返回当前父节点</p><p>即：对于一个节点，如果其具有左子树，那么将其左子树上的最右节点作为其前驱节点，第一次访问时先将其右指针指向此节点，作为第二次访问判断左子树遍历完成的标志。<br>这样，就可以使得让有左孩子的节点被访问两次，没有左孩子的节点被访问一次</p><p>在此基础上实现前中后序遍历：</p><h4 id="前序">前序</h4><p>Morris遍历加工成先序遍历的规则是：</p><ul><li>如果一个节点只能被访问一次，被访问时加入答案列表</li><li>如果一个节点能被访问两次，在第一次被访问时加入列表</li></ul><h5 id="代码实现">代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">preorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">processor := root.Left</span><br><span class="line"><span class="keyword">for</span> processor.Right != <span class="literal">nil</span> &amp;&amp; processor.Right != root &#123;</span><br><span class="line">processor = processor.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 左子树安全</span></span><br><span class="line"><span class="keyword">if</span> processor.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">processor.Right = root</span><br><span class="line">root = root.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 左子树已经遍历完全</span></span><br><span class="line">processor.Right = <span class="literal">nil</span></span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有左子树</span></span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序">中序</h4><p>Morris遍历加工成中序遍历的规则是：</p><ul><li>如果一个节点只能被访问一次，被访问时加入答案列表</li><li>如果一个节点能被访问两次，在第二次被访问时加入列表</li></ul><h5 id="代码实现-2">代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">inorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 使用morris遍历</span></span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 先看有无左子节点，需要寻找的是当前节点的中序遍历前驱节点</span></span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">processor := root.Left</span><br><span class="line"><span class="keyword">for</span> processor.Right != <span class="literal">nil</span> &amp;&amp; processor.Right != root &#123;</span><br><span class="line">processor = processor.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> processor.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">processor.Right = root</span><br><span class="line">root = root.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 已经遍历完了左子树</span></span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">processor.Right = <span class="literal">nil</span></span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 没有左子树，直接往右走</span></span><br><span class="line">res = <span class="built_in">append</span>(res, root.Val)</span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序">后序</h4><p>Morris遍历加工成中序遍历的规则是：</p><ul><li>如果一个节点能被访问两次，在第二次被访问时自底向上加入该节点左子树的右边界进答案列表</li><li>当所有节点遍历完后，单独自底向上加入整棵树的右边界</li></ul><h5 id="代码实现-3">代码实现</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">postorderTraversal</span><span class="params">(root *TreeNode)</span></span> (res []<span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 这个比较麻烦，需要实现倒序、收割右子树</span></span><br><span class="line">reveseInts := <span class="function"><span class="keyword">func</span><span class="params">(nums []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(nums)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n/<span class="number">2</span>; i++ &#123;</span><br><span class="line">nums[i], nums[n-i<span class="number">-1</span>] = nums[n-i<span class="number">-1</span>], nums[i]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">addPath := <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> &#123;</span><br><span class="line">size := <span class="built_in">len</span>(res)</span><br><span class="line"><span class="keyword">for</span> node != <span class="literal">nil</span> &#123;</span><br><span class="line">res = <span class="built_in">append</span>(res, node.Val)</span><br><span class="line">node = node.Right</span><br><span class="line">&#125;</span><br><span class="line">reveseInts(res[size:])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> root != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123; <span class="comment">// 左子树存在</span></span><br><span class="line">processor := root.Left</span><br><span class="line"><span class="keyword">for</span> processor.Right != <span class="literal">nil</span> &amp;&amp; processor.Right != root &#123;</span><br><span class="line">processor = processor.Right</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> processor.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">processor.Right = root</span><br><span class="line">root = root.Left</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">processor.Right = <span class="literal">nil</span></span><br><span class="line">addPath(root.Left)</span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">root = root.Right</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">addPath(root)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语唠唠">结语<s>唠唠</s></h3><p><code>Morris</code>遍历的话，确实可以降低空间复杂度，但是它遍历时改变了二叉树的结构，如果在多线程的场景下，多个线程同时读写(一个写，多个读)某个二叉树的数据，那会非常危险。如果明确要求不可修改二叉树，那这种方案就不适用</p><p>有空看能不能补补图(太懒力:|</p><p>溜了~~</p>]]></content>
      
      
      <categories>
          
          <category> Arithmetic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-语法(1)</title>
      <link href="/2023/12/23/blog17/"/>
      <url>/2023/12/23/blog17/</url>
      
        <content type="html"><![CDATA[<h2 id="Java笔记语法篇">Java笔记语法篇</h2><h3 id="基本数据类型">基本数据类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">位数</th><th style="text-align:center">字节数</th><th style="text-align:center">默认初始值</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td style="text-align:center">8</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">-128(2<sup>7</sup>)~127</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">16</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">-32768(2<sup>15</sup>)~32767</td></tr><tr><td style="text-align:center">int</td><td style="text-align:center">32</td><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">-2147483648(2<sup>31</sup>)~2147483647</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">64</td><td style="text-align:center">8</td><td style="text-align:center">0L</td><td style="text-align:center">-9223372036854775808(2<sup>63</sup>)~9223372036854775807</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">16</td><td style="text-align:center">2</td><td style="text-align:center">‘u0000’</td><td style="text-align:center">0~65535(2<sup>16</sup>-1)</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">32</td><td style="text-align:center">4</td><td style="text-align:center">0f</td><td style="text-align:center">1.4E-45~3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">64</td><td style="text-align:center">8</td><td style="text-align:center">0d</td><td style="text-align:center">4.9E-324~1.7976931348623157E308</td></tr><tr><td style="text-align:center">boolean</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">false</td><td style="text-align:center">ture / false</td></tr></tbody></table><h4 id="对于boolean">对于<code>boolean</code></h4><p>在<code>Java</code>虚拟机中对其支持有限:</p><ul><li>单个<code>boolean</code>类型的变量表达式在编译时会被转换成<code>int</code>类型，用<code>1</code>表示<code>true</code>，用<code>0</code>表示<code>false</code>，即4个字节;</li><li>而对<code>boolean</code>数组的操作则同<code>byte</code>数组等价，即1个字节。另外，其具体实现也依赖于<code>JVM</code>厂商</li></ul><h4 id="上述基础类型对应的包装类型">上述基础类型对应的包装类型</h4><ul><li><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code>、<code>Float</code>、<code>Double</code>、<code>Boolean</code> ；</li><li>将基本类型转换成包装类型即“装箱<code>(boxing)</code>”，反之“拆箱<code>(unboxing)</code>”</li></ul><h4 id="基本类型与包装类型的区别">基本类型与包装类型的区别</h4><ul><li>基础类型不具备对象特性，所以:<ul><li>在需要使用<code>Object</code>的地方(比如泛型)必须是包装类型</li><li>且作为类,包装类型可以为<code>null</code>；<code>==</code>对于基本类型是比较值，对于包装类型则是比较内存地址，包装类型对象之间值的比较用<code>equals()</code>方法</li></ul></li><li>基本数据类型的局部变量放在<code>Java</code>虚拟机的局部变量表/栈中，未被<code>static</code>修饰的成员变量放在堆内存中；而对于包装类，实例放在堆，引用放在栈。一般基本类型更高效。</li><li>基础类型相比包装类型占用空间小</li></ul><hr><h3 id="自动拆装箱与包装类缓存机制">自动拆装箱与包装类缓存机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">711</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> num1;</span><br></pre></td></tr></table></figure><h4 id="说明">说明</h4><p>这里前一条语句发生自动装箱，将<code>int</code>转换为<code>Interger</code>，实际上使用的是包装类的<code>ValueOf()</code>方法 --&gt; <code>Integer.ValueOf()</code>；后一条语句发生自动拆箱，调用<code>intValue()</code>方法 --&gt; <code>num1.intValue()</code></p><h4 id="自动拆装箱发生">自动拆装箱发生</h4><ul><li>将基本数据类型放入集合类（装）</li><li>基本类型与包装类型大小比较（拆）</li><li>包装类型的运算（拆）</li><li>三目运算符中，第二、三位操作数有包装类时就拆</li><li>方法参数/返回值类型不匹配，自动拆装</li></ul><h4 id="包装类缓存机制">包装类缓存机制</h4><p>大部分包装类（除了<code>Float</code>、<code>Double</code>）使用缓存机制来提升性能：</p><p>在一定范围内利用自动装箱（<code>ValueOf()</code>方法）创建包装类对象时，会从缓存（常量池）中寻找指定数值（一般来说各个包装类默认创建了一个静态数组<code>cache[]</code>,对应范围，所以只要在这个范围内理论上都有），未找到则新建对象并返回引用；找到则直接返回引用</p><ul><li>这个范围：<ul><li><code>Byte</code>、<code>Shotr</code>、<code>Integer</code>、<code>Long</code>：-128 ~ 127</li><li><code>Character</code>: 0 ~ 127</li><li><code>Boolean</code>: True、False</li></ul></li><li>不在这个范围自动装箱或者直接new的包装类都会新建一个对象，且不会放入缓存，也不会复用（存储于堆空间）</li></ul><p>由于包装类缓存机制，从缓存得来的对象引用比较时<code>==</code>(比地址)会为<code>true</code>，新建而来则为<code>false</code>，所以包装类对象实例之间值的比较最好用<code>equals()</code>方法（包装类默认重写了equals()方法，先看类型，再比较值）</p><p>另外，频繁拆装箱会影响系统性能，尽量避免不必要的拆装箱操作</p><hr><h3 id="高精度计算">高精度计算</h3><p>虽说<code>float</code>和<code>double</code>可以满足大部分开发需要，但是精度在某些场景下仍然不够，这时候就需要<code>BigDecimal</code>来进行浮点数的创建运算：</p><h4 id="构造">构造</h4><p>为防止精度丢失，推荐使用<code>BigDecimal(Sting val)</code>构造方法或者<code>BigDecimal.valueOf(double val)</code>静态方法（此方法内部使用<code>Double</code>的<code>toString()</code>方法，采用双精度浮点数<code>(double)</code>截断策略）来创建对象（实际上<code>BigDecimal</code>支持使用<code>int</code>、<code>double</code>、<code>long</code>、<code>String</code>来作为构造方法的参数，但是使用<code>double</code>的构造方法结果有一定的不可预知性）</p><h4 id="运算">运算</h4><p>运算方法：</p><ul><li>加 --&gt; <code>add()</code></li><li>减 --&gt; <code>subtract()</code></li><li>乘 --&gt; <code>multiply()</code></li><li>除 --&gt; <code>divide()</code>，且最好尽量使用<code>3</code>参数版本(<code>num</code>除数,<code>scale</code>保留小数位数,<code>roundingMode</code>保留规则)，以针对出现无限循环小数的情况</li><li>大小比较 --&gt; <code>compareTo()</code>（忽略精度<code>scale</code>） ，-1即小于，0是等于，1为大于</li></ul><h4 id="注意点">注意点</h4><ul><li>最好不使用<code>equals()</code>方法比较值（会比较精度，1.0和1就会不相等）</li><li><code>setScale()</code>方法设置保留小数位、保留规则(建议为<code>RoundingMode.HALF_EVEN</code>，四舍六入五成双)</li><li>格式化可结合<code>NumberFormat</code>类使用</li></ul><h3 id="长整数计算">长整数计算</h3><p>既然有高精度浮点运算，那么在整数区域也有长整数<code>BigInteger</code>类型，来处理<code>Integer</code>、<code>Long</code>位数不够的情况：</p><h4 id="构造-2">构造</h4><p>构造方法：<code>BigInteger</code>类支持的构造方法有不少，可以传入<code>byte []</code>、<code>char []</code>、<code>String</code>、<code>int</code>、<code>int []</code>、<code>long</code>，同时还可以加入更多参数指定进制规则等等</p><h4 id="运算-2">运算</h4><p>同理，因为位数过高，所以肯定没法用常规的运算符进行运算，只能使用其类方法：</p><ul><li><code>add()</code> --&gt; 加</li><li><code>subtract()</code> --&gt; 减</li><li><code>multiply()</code> --&gt; 乘</li><li><code>divide()</code> --&gt; 除</li><li><code>mod()</code> --&gt; 取模(参数需要<code>&gt;=0</code>)</li><li><code>remainder()</code> --&gt; 求余</li><li><code>pow()</code> --&gt; 平方(同理，参数需<code>&gt;=0</code>)</li><li><code>abs()</code> --&gt; 绝对值</li><li><code>negate()</code> --&gt; 相反值</li><li><code>compareTo()</code> --&gt; 比较大小，规则同<code>BigDecimal</code></li></ul><h4 id="另外">另外</h4><p>还可以使用<code>xxxValue()</code>方法，将<code>BigInteger</code>转换成基本数据类型，亦或者使用<code>toString()</code>方法或者<code>toByteArray()</code>方法转换成某种进制的字符串/字节数组</p><hr><h3 id="求余和取模">求余和取模</h3><p>这二者是有区别的（不光是<code>Java</code>，其他高级语言也是）:</p><ul><li>对于整数基本类型，<code>%</code>就是求余，而<code>Math.floorMod()</code>方法才是取模。</li><li>当参与运算的两个数符号不一致时，对于<code>a模b</code>，运算结果符号与<code>b</code>一致；而<code>a余b</code>结果符号则和<code>a</code>相同。因为对于<code>r=a - c*b</code>，取模时<code>c</code>会向<code>负无穷</code>方向舍入（<code>floor()</code>方法），而求余则向<code>0</code>方向舍入（<code>fix()</code>方法）</li></ul><hr><h3 id="移位运算符">移位运算符</h3><h4 id><code>&lt;&lt;</code></h4><p>左移运算符，高位丢弃，低位取零。<code>x &lt;&lt; 1</code>在不溢出的情况下相当于<code>x * 2</code></p><h4 id="-2"><code>&gt;&gt;</code></h4><p>右移运算符，高位补符号位(即正数高位补0，负数高位补1)，低位丢弃。所以 <code>x &gt;&gt; 2 </code> 相当于 <code>x / 2</code></p><h4 id="-3"><code>&gt;&gt;&gt;</code></h4><p>无符号右移，和<code>&gt;&gt;</code>不同的是所有空位都以0补齐</p><h4 id="注：">注：</h4><ol><li>移位操作实际上支持的类型只有<code>int</code>和<code>long</code>，编译器对<code>short</code>、<code>byte</code>、<code>char</code>类型位移前都会先转换为<code>int</code>再操作</li><li>移位位数超过数值所占位数时会先求余<code>%</code>再移，<code>int</code>对应<code>32</code>位，<code>long</code>对应<code>64</code>位</li></ol><hr><h3 id="方法重写">方法重写</h3><p>重写是子类对父类方法的重新改造，外部样子(原本的框架)不变，改变内部逻辑<br>重写规范：</p><ul><li>构造方法无法重写</li><li>父子方法名、参数列表必须相同</li><li>子类方法访问修饰符范围大于等于父类</li><li>子类方法返回值类型应和父类方法相等或者更小</li><li>子类方法抛出的异常范围小于等于父类</li><li>如果父类方法访问修饰符为<code>private</code>/<code>final</code>/<code>static</code>，那么子类就无法重写此方法</li></ul><hr><h3 id="方法的可变长参数机制">方法的可变长参数机制</h3><p><code>Java</code>5提供了可变长参数，允许在调用方法时传入不定长度的参数：</p><h4 id="语法">语法</h4><p>在参数类型后跟一个<code>...</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeArgs</span><span class="params">(<span class="type">int</span> ... args)</span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> arg : args)&#123;</span><br><span class="line">      System.out.println(arg);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意">注意</h4><ol><li>一个方法有且仅能有一个可变长参数</li><li>可变长参数只能作为此方法的最后一个参数</li><li>遇到方法重载时优先匹配固定参数方法，其次再是可变长参数</li><li>其本质上还是基于数组实现，可变长参数编译之后会转换成一个数组</li></ol><hr><h3 id="拷贝">拷贝</h3><h4 id="前置说明">前置说明</h4><blockquote><p><strong>值传递</strong>：接收实参的拷贝，即创建副本，对形参修改不影响实参<br><strong>引用传递</strong>： 接收实参所引用的对象在堆中的地址，不会创建副本，对形参修改影响实参</p></blockquote><p><strong>在<code>Java</code>中，是只有值传递的</strong></p><ul><li>引用拷贝: 就是把一个引用数据类型的值复制一下，给一个新的引用数据类型，它俩指向的对象的地址是一样的。</li></ul><p><strong>注</strong>：因为在<code>Java</code>中引用数据类型存储的就是对象地址值，所以传值就把引用复制了一下，本质上就是值传递。这里区别于<code>C++</code>中的<code>&amp;</code>，把一个变量的地址作为参数传过去，传的不是实参的值，是其地址</p><h4 id="对象拷贝">对象拷贝</h4><p>创建一个新对象，地址不一样</p><h5 id="浅拷贝：">浅拷贝：</h5><p>针对原始对象中的成员变量进行值传递和引用拷贝，所以如果改变复制对象或者原始对象中的引用类型变量，会同时影响对方。<br>一般使用默认的<code>clone()</code>方法即可</p><h5 id="深拷贝：">深拷贝：</h5><p>对原始对象中的基本数据类型变量进行值传递，但是对引用数据类型变量进行<strong>空间申请</strong>和<strong>此变量指向的对象复制</strong>，即对整个原始对象进行拷贝，产生一个独立的新对象。<br>可以借助重写<code>clone()</code>方法或者通过对象序列化(<code>Serializable</code>)实现<br>另外，由深拷贝性质可知，如果引用数据类型成员变量用<code>final</code>修饰深拷贝将失败，没法儿重新赋值</p><hr><h3 id="hashCode-和equals">hashCode()和equals()</h3><p>之前一直以为但凡重写了<code>equals()</code>就必须重写<code>hashCode()</code>，但是实际上不是的：</p><ul><li><p>在不创建类对应的散列表(<code>Hashset``HashMap</code>等等)时，两者无关；</p></li><li><p>反之则确实需要重写，散列表中高效查找及去重会用到(定位链表/数组索引位置)</p></li></ul><hr><h3 id="String">String</h3><h4 id="字符存储">字符存储</h4><p><code>Java9</code>之前使用<code>char[]</code>，从其开始使用<code>byte[]</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br></pre></td></tr></table></figure><blockquote><p>新版的 String 其实支持两个编码方案：Latin-1 和 UTF-16。<br>如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。<br>Latin-1 编码方案下，byte 占 1 个字节(8 位)，char 占用 2 个字节（16），byte 相较 char 节省一半的内存空间。<br>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。<br>如果字符串中包含的汉字超过 Latin-1 可表示范围内的字符，byte 和 char 所占用的空间是一样的</p></blockquote><h4 id="Sting不可变的理解："><code>Sting</code>不可变的理解：</h4><blockquote><ol><li>保存字符串的数组被<code>final</code>修饰且为私有，同时<code>String</code>类没有提供或暴露修改这个字符串的方法</li><li><code>String</code>类本身被<code>final</code>修饰无法被继承，避免子类破坏</li></ol></blockquote><h4 id="StringBuilder和StringBuffer："><code>StringBuilder</code>和<code>StringBuffer</code>：</h4><ul><li>都继承自<code>AbstracStringBuilder</code>，其没有使用<code>final</code>和<code>private</code>关键字，同时提供很多修改字符串的方法</li><li><code>StringBuffer</code>对方法或者调用的方法加了同步锁，线程安全；而<code>StringBuilder</code>则没有，是非线程安全</li><li>相同情况下<code>StringBuilder</code>比<code>StringBuffer</code>性能稍高</li></ul><p><code>JDK9</code>之前<code>String</code>字符串<code>+</code>拼接借助<code>StringBuilder</code>调用<code>append()</code>，之后改为动态方法<code>makeConcatWithConstants()</code></p><p><strong>拼接优化可以研究一下</strong></p><h4 id="String-itern"><code>String.itern()</code></h4><p>其作用是对字符串常量池进行数据修改或者查找</p><p><code>JDK7</code>之前字符串常量池放在永久代，其中存储对象。所以<code>itern()</code>方法会先去看字符串常量池里有没有这个对象，没有就创建；有就返回<br><code>JDK7</code>开始字符串常量池迁移到堆中，存储引用。因此<code>itern()</code>会在字符串常量池查找引用，没有的话就创建一个<strong>指向堆区对应的已有字符串对象地址</strong>的引用；有则返回引用</p><hr><h3 id="常量折叠-Constant-Folding">常量折叠(Constant Folding)</h3><p>编译过程中，Javac编译器会进行常量折叠代码优化：</p><blockquote><p>常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。<br><br>对于 String str3 = “str” + “ing”; 编译器会给你优化成 String str3 = “string”; <br><br>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：<br>1.基本数据类型( byte、boolean、short、char、int、float、long、double)以及字符串常量。<br>2.final 修饰的基本数据类型和字符串变量<br>3.字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</p></blockquote><hr><h3 id="泛型">泛型</h3><p><strong>注意</strong>： 静态方法中无法访问类的泛型成员变量(因为静态方法加载先于类的实例化)，需要用到的话可以在静态方法上声明、使用自己的泛型参数，与类的泛型参数无关</p><hr><h3 id="序列化与反序列化">序列化与反序列化</h3><h4 id="概念">概念</h4><blockquote><p><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程<br><strong>反序列化</strong>： 将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</p></blockquote><p>序列化协议对应<code>TCP/IP模型</code>应用层的表示层</p><h4 id="使用">使用</h4><p>对于<code>Java</code>自带的序列化方式，只需实现<code>java.io.Serializable</code>接口或者<code>Externalizable</code>接口。这里主要记录/针对前者</p><h5 id="serialVersionUID："><code>serialVersionUID</code>：</h5><blockquote><p>序列化号<code>serialVersionUID</code>属于版本控制的作用。<br>反序列化时，会检查<code>serialVersionUID</code>是否和当前类的<code>serialVersionUID</code>一致。<br>如果<code>serialVersionUID</code>不一致则会抛出<code>InvalidClassException</code>异常。<br>强烈推荐每个序列化类都手动指定其<code>serialVersionUID</code>，如果不手动指定，那么编译器会动态生成默认的<code>serialVersionUID</code></p></blockquote><p>显式指定<code>serialVersionUID</code>是在类中使用<code>static</code>和<code>final</code>关键字修饰一个<code>long</code>类型变量，变量名为<code>serialVersionUID</code></p><h5 id="某些字段不进行序列化">某些字段不进行序列化</h5><p>可以使用<code>transient</code>关键字修饰不想进行序列化的变量：</p><blockquote><p>对象实例中被<code>transient</code>修饰的变量序列化会被阻止，反序列化时变量值不会持久化、恢复</p></blockquote><ul><li><code>transient</code>只能修饰变量，不能修饰类和方法</li><li><code>transient</code>修饰的变量反序列化后其值会被设置为该类型的默认值</li><li>被<code>static</code>修饰的变量，存在于方法区，无论有无<code>transient</code>修饰都不会被序列化。(<code>serialVersionUID</code>比较特殊，作为一致性标识，在对象实例序列化时其也会被序列化到二进制字节流，反序列化时会一并解析并做一致性判断。)</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux(1)</title>
      <link href="/2023/12/23/blog16/"/>
      <url>/2023/12/23/blog16/</url>
      
        <content type="html"><![CDATA[<h1>Linux小记</h1><p>记录一些针对于<code>Linux</code>的操作指令，服务器/开发机等</p><h2 id="服务器上CentOS的一些指令">服务器上CentOS的一些指令</h2><h3 id="防火墙">防火墙</h3><p>使用系统指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld #开启</span><br><span class="line">systemctl stop firewalld #关闭</span><br><span class="line">systemctl restart firewalld #重启</span><br><span class="line">systemctl reload firewalld #重新加载</span><br><span class="line">systemctl status firewalld #查看状态</span><br><span class="line">systemctl enable firewalld #设置开机自启动</span><br><span class="line">systemctl disable firewalld #取消开机自启动</span><br></pre></td></tr></table></figure><hr><p>使用<code>firewall-cmd</code>指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --state #查看状态</span><br><span class="line">firewall-cmd --reload #重新加载</span><br><span class="line">firewall-cmd --add-port=80/tcp --permanent #永久添加端口</span><br><span class="line">firewall-cmd --list-ports #查看端口</span><br><span class="line">firewall-cmd --list-all #查看所有规则</span><br><span class="line">firewall-cmd --list-services #查看所有服务</span><br><span class="line">firewall-cmd --add-service=http #添加服务</span><br><span class="line">firewall-cmd --add-service=http --permanent #永久添加服务</span><br><span class="line">firewall-cmd --remove-service=http #删除服务</span><br></pre></td></tr></table></figure><hr><h2 id="记录一些ubuntu22-04上的操作">记录一些ubuntu22.04上的操作</h2><h3 id="美化操作">美化操作</h3><h4 id="更新">更新</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure><h4 id="安装相关依赖软件">安装相关依赖软件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gnome-tweaks chrome-gnome-shell</span><br><span class="line">sudo apt install gnome-shell-extensions</span><br></pre></td></tr></table></figure><h4 id="美化">美化</h4><p>去到<code>Firefox</code>或者<code>Chrome</code>中下载<code>gnome</code>插件，然后下载对应的美化包、执行操作。这玩意儿装的扩展可以在系统菜单下的扩展里找到打开</p><hr><h3 id="flameshot安装使用">flameshot安装使用</h3><h4 id="安装">安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install flameshot</span><br></pre></td></tr></table></figure><h4 id="设置快捷键">设置快捷键</h4><p>使用指令<code>flameshot gui</code>即可对屏幕进行截取，一般在设置中增加自定义快捷键<code>F1</code>，将其与截屏指令绑定</p><hr><h3 id="对于aria2的安装使用">对于aria2的安装使用</h3><p><a href="https://github.com/aria2/aria2">aria2的github仓库</a></p><h4 id="基本">基本</h4><h5 id="安装-2">安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install aria2</span><br></pre></td></tr></table></figure><h5 id="配置">配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /etc/aria2    #新建文件夹 </span><br><span class="line">touch /etc/aria2/aria2.session    #新建session文件</span><br><span class="line">chmod 777 /etc/aria2/aria2.session    #设置aria2.session可写 </span><br><span class="line">vim /etc/aria2/aria2.conf    #创建配置文件</span><br></pre></td></tr></table></figure><p>这是<code>aria2.conf</code>文件对应内容，具体配置可更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 全局设置 ## ============================================================</span></span><br><span class="line"><span class="comment"># 日志</span></span><br><span class="line"><span class="comment">#log-level=warn</span></span><br><span class="line"><span class="comment">#log=/PATH/.aria2/aria2.log</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 后台运行</span></span><br><span class="line"><span class="comment">#daemon=true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 下载位置, 默认: 当前启动位置</span></span><br><span class="line"><span class="built_in">dir</span>=/home/Aria2/Downloads/</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 从会话文件中读取下载任务 都用绝对路径</span></span><br><span class="line">input-file=/etc/aria2/aria2.session</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在Aria2退出时保存`错误/未完成`的下载任务到会话文件</span></span><br><span class="line">save-session=/etc/aria2/aria2.session</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0</span></span><br><span class="line">save-session-interval=30</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 断点续传</span></span><br><span class="line"><span class="built_in">continue</span>=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M</span></span><br><span class="line"><span class="comment">#disk-cache=32M</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc</span></span><br><span class="line"><span class="comment"># 预分配所需时间: none &lt; falloc ? trunc &lt; prealloc</span></span><br><span class="line"><span class="comment"># falloc和trunc则需要文件系统和内核支持</span></span><br><span class="line"><span class="comment"># NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项</span></span><br><span class="line">file-allocation=none</span><br><span class="line"><span class="comment"># 客户端伪装</span></span><br><span class="line">user-agent=netdisk;5.2.6;PC;PC-Windows;6.2.9200;WindowsBaiduYunGuanJia</span><br><span class="line">referer=http://pan.baidu.com/disk/home</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 禁用IPv6, 默认:false</span></span><br><span class="line">disable-ipv6=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 其他</span></span><br><span class="line">always-resume=<span class="literal">true</span></span><br><span class="line">check-integrity=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## 下载位置 ## ============================================================</span></span><br><span class="line"><span class="comment"># 最大同时下载任务数, 运行时可修改, 默认:5</span></span><br><span class="line">max-concurrent-downloads=10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 同一服务器连接数, 添加时可指定, 默认:1</span></span><br><span class="line">max-connection-per-server=10</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M</span></span><br><span class="line"><span class="comment"># 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载</span></span><br><span class="line">min-split-size=10M</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 单个任务最大线程数, 添加时可指定, 默认:5</span></span><br><span class="line"><span class="built_in">split</span>=5</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 整体下载速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="comment">#max-overall-download-limit=0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 单个任务下载速度限制, 默认:0</span></span><br><span class="line"><span class="comment">#max-download-limit=0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 整体上传速度限制, 运行时可修改, 默认:0</span></span><br><span class="line"><span class="comment">#max-overall-upload-limit=0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 单个任务上传速度限制, 默认:0</span></span><br><span class="line"><span class="comment">#max-upload-limit=0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## RPC设置 ## ============================================================</span></span><br><span class="line"><span class="comment"># 启用RPC, 默认:false</span></span><br><span class="line">enable-rpc=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 允许所有来源, 默认:false</span></span><br><span class="line">rpc-allow-origin-all=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 允许非外部访问, 默认:false</span></span><br><span class="line">rpc-listen-all=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 事件轮询方式, 取值:[epoll, kqueue, port, poll, select], 不同系统默认值不同</span></span><br><span class="line"><span class="comment">#event-poll=select</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># RPC监听端口, 端口被占用时可以修改, 默认:6800</span></span><br><span class="line">rpc-listen-port=6800</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项</span></span><br><span class="line"><span class="comment">#rpc-secret=&lt;TOKEN&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 是否启用 RPC 服务的 SSL/TLS 加密,</span></span><br><span class="line"><span class="comment"># 启用加密后 RPC 服务需要使用 https 或者 wss 协议连接</span></span><br><span class="line"><span class="comment">#rpc-secure=true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在 RPC 服务中启用 SSL/TLS 加密时的证书文件,</span></span><br><span class="line"><span class="comment"># 使用 PEM 格式时，您必须通过 --rpc-private-key 指定私钥</span></span><br><span class="line"><span class="comment">#rpc-certificate=/path/to/certificate.pem</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 在 RPC 服务中启用 SSL/TLS 加密时的私钥文件</span></span><br><span class="line"><span class="comment">#rpc-private-key=/path/to/certificate.key</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">## BT/PT下载相关 ## ============================================================</span></span><br><span class="line"><span class="comment"># 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true</span></span><br><span class="line"><span class="comment">#follow-torrent=true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># BT监听端口, 当端口被屏蔽时使用, 默认:6881-6999</span></span><br><span class="line">listen-port=51413</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 单个种子最大连接数, 默认:55</span></span><br><span class="line"><span class="comment">#bt-max-peers=55</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开DHT功能, PT需要禁用, 默认:true</span></span><br><span class="line">enable-dht=<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 打开IPv6 DHT功能, PT需要禁用</span></span><br><span class="line"><span class="comment">#enable-dht6=false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># DHT网络监听端口, 默认:6881-6999</span></span><br><span class="line"><span class="comment">#dht-listen-port=6881-6999</span></span><br><span class="line"> </span><br><span class="line">dht-file-path=/opt/var/aria2/dht.dat</span><br><span class="line">dht-file-path6=/opt/var/aria2/dht6.dat</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 本地节点查找, PT需要禁用, 默认:false</span></span><br><span class="line"><span class="comment">#bt-enable-lpd=false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 种子交换, PT需要禁用, 默认:true</span></span><br><span class="line">enable-peer-exchange=<span class="literal">false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 每个种子限速, 对少种的PT很有用, 默认:50K</span></span><br><span class="line"><span class="comment">#bt-request-peer-speed-limit=50K</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置 peer id 前缀</span></span><br><span class="line">peer-id-prefix=-TR2770-</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当种子的分享率达到这个数时, 自动停止做种, 0为一直做种, 默认:1.0</span></span><br><span class="line">seed-ratio=0</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 强制保存会话, 即使任务已经完成, 默认:false</span></span><br><span class="line"><span class="comment"># 较新的版本开启后会在任务完成后依然保留.aria2文件</span></span><br><span class="line"><span class="comment">#force-save=false</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># BT校验相关, 默认:true</span></span><br><span class="line"><span class="comment">#bt-hash-check-seed=true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 继续之前的BT任务时, 无需再次校验, 默认:false</span></span><br><span class="line">bt-seed-unverified=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 保存磁力链接元数据为种子文件(.torrent文件), 默认:false</span></span><br><span class="line">bt-save-metadata=<span class="literal">true</span></span><br><span class="line"> </span><br><span class="line">bt-max-open-files=16</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Http/FTP 相关</span></span><br><span class="line">connect-timeout=120</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h5 id="启动aria2">启动<code>aria2</code></h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c --conf-path=/etc/aria2/aria2.conf</span><br></pre></td></tr></table></figure><h5 id="使用">使用</h5><p>在可以正常启动的情况下，可以开启后台启动（终端不会显示进程日志）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br></pre></td></tr></table></figure><p>接下来选择使用<code>web</code>端或者客户端<code>gui</code>形式对下载任务、配置来可视化操作，前者在浏览器中下载“Aria2下载器集成组件”，后者可在<code>aria2</code>的安装路径下使用命令行启动<br><img src="/2023/12/23/blog16/aria2_web.png" class="lazyload" data-srcset="/2023/12/23/blog16/aria2_web.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="aria2-web管理"></p><h4 id="可选">可选</h4><p>设置<code>aria2</code>开机启动</p><h5 id="新建启动脚本">新建启动脚本</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides: aria2</span></span><br><span class="line"><span class="comment"># Required-Start: $remote_fs $network</span></span><br><span class="line"><span class="comment"># Required-Stop: $remote_fs $network</span></span><br><span class="line"><span class="comment"># Default-Start: 2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop: 0 1 6</span></span><br><span class="line"><span class="comment"># Short-Description: Aria2 Downloader</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">echo</span> -n <span class="string">&quot;已开启Aria2c&quot;</span></span><br><span class="line"> sudo aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">echo</span> -n <span class="string">&quot;已关闭Aria2c&quot;</span></span><br><span class="line"> killall aria2c</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line"> </span><br><span class="line"> killall aria2c</span><br><span class="line"> sudo aria2c --conf-path=/etc/aria2/aria2.conf -D</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h5 id="修改文件权限（a-x）">修改文件权限（a+x）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 755 /etc/init.d/aria2c</span><br></pre></td></tr></table></figure><h5 id="添加开机启动服务">添加开机启动服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo update-rc.d aria2c defaults</span><br></pre></td></tr></table></figure><h5 id="启动">启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service aria2c start</span><br></pre></td></tr></table></figure><h5 id="可查看服务状态">可查看服务状态</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemclt status aria2c</span><br></pre></td></tr></table></figure><hr><h3 id="安装搜狗输入法">安装搜狗输入法</h3><p><a href="https://shurufa.sogou.com/linux/guide">搜狗官方安装文档</a></p><h4 id="更新-2">更新</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><h4 id="安装fcitx">安装<code>fcitx</code></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install fcitx</span><br></pre></td></tr></table></figure><p>然后可以使用优化或者命令行使得<code>fcitx</code>可以开机自启动</p><h4 id="安装搜狗输入法-2">安装搜狗输入法</h4><h5 id="去到搜狗输入法官网下载对应版本">去到搜狗输入法官网下载对应版本,</h5><p>–&gt; <a href="https://shurufa.sogou.com/linux">官网</a>，然后解压安装</p><h5 id="安装-3">安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2</span><br><span class="line">sudo apt install libgsettings-qt1</span><br></pre></td></tr></table></figure><p>重启之后就能看到<code>Fcitx</code>对应的输入法了，再对其稍稍配置</p><h5 id="卸载默认的ibus输入法框架（可选）">卸载默认的<code>ibus</code>输入法框架（可选）</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt purge ibus</span><br></pre></td></tr></table></figure><hr><h3 id="针对firefox无法打开简书">针对firefox无法打开简书</h3><ol><li><p>地址栏输入<code>about:config</code>，接受风险进入<br><img src="/2023/12/23/blog16/jianshu_firefox_config.png" class="lazyload" data-srcset="/2023/12/23/blog16/jianshu_firefox_config.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="风险警告"></p></li><li><p>上方搜索栏查找<code>general.useragent.overrride</code>，未找到则新建字符串，填入<code>Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/119.0</code><br><img src="/2023/12/23/blog16/jianshu_firefox.png" class="lazyload" data-srcset="/2023/12/23/blog16/jianshu_firefox.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="新建字符串">，后续即可访问</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis-Plus(2)</title>
      <link href="/2023/12/23/blog15/"/>
      <url>/2023/12/23/blog15/</url>
      
        <content type="html"><![CDATA[<h2 id="Mybatis-plus小记">Mybatis-plus小记</h2><p>记录些小坑小点</p><h3 id="TableField"><code>@TableField</code></h3><p>注解里的内容和表字段名对应，标了这个注解就必须一摸一样捏…<br>要不然查不到</p><hr><h3 id="命名问题">命名问题</h3><p>表中字段名如果是以 <code>_</code> 来分隔，则实体类成员变量名使用驼峰命名法，比如<code>user</code>表中有个 <code>user_id</code> 字段，那么实体类 <code>User</code> 中就是 <code>userId</code></p><p>否则使用查询语句时会映射不到，导致明明有数据却查出来为 <code>null</code></p><hr><h3 id="构造器的in">构造器的<code>in</code></h3><p>使用<code>wrapper</code>（条件构造器）时，可以传<code>List</code>；</p><p>比如说有个 <code>List</code> ，里面放的是userId，我现在想构造一个能一次性把这些 <code>id</code> 对应的 <code>user</code> 全查出来的 <code>wrapper</code> ，是不能写 <code>eq</code> 的，用 <code>eq</code> 会和 <code>List</code> 这个对象比较；而用 <code>in</code> 的话，在确保字段和 <code>List</code>元素一致的情况是可以的。</p><p>另外有个解决方法是放在循环中，或者在自定义语句中配置 <code>in</code> 对应的 <code>foreach</code></p><hr><h3 id="TableLogic">@TableLogic</h3><p>逻辑删除的配置和使用不要忘记：</p><ul><li><code>application.yml</code>中配置:<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line"> <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">       <span class="attr">logic-delete-field:</span> <span class="comment">#&#123;全局逻辑删除实体字段名&#125;</span></span><br><span class="line">       <span class="attr">logic-delete-value:</span> <span class="comment">#&#123;逻辑已删除值，默认为1&#125;</span></span><br><span class="line">       <span class="attr">logic-not-delete-value:</span> <span class="comment">#&#123;逻辑未删除值，默认为0&#125;</span></span><br></pre></td></tr></table></figure></li><li>实体类上加上<code>@TableLogic</code>注解</li></ul><hr><h3 id="TableId">@TableId</h3><p>此注解加在实体类对应数据库主键的字段上，其包含属性<code>value</code>和<code>type</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableId(value = &quot;#&#123;主键名称&#125;&quot;, type = TdType.#&#123;枚举类型&#125;)</span></span><br></pre></td></tr></table></figure><img src="/2023/12/23/blog15/mb_tableId.png" class="lazyload" data-srcset="/2023/12/23/blog15/mb_tableId.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="官方说明" with="70%"><p>一般用自增逻辑<code>type = IdType.AUTO</code></p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql(2)</title>
      <link href="/2023/12/23/blog14/"/>
      <url>/2023/12/23/blog14/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql小记">Mysql小记</h2><h3 id="外键约束">外键约束</h3><p>设置主从表主键、外键（主键所在为主表，外键所在为从表）的时候，注意外键约束属性</p><ul><li><code>CASCADE</code> : 父表<code>delete</code>/<code>updatate</code>时，子表同步<code>delete</code>/<code>update</code>关联记录</li><li><code>SET NULL</code> : 父表<code>delete/update</code>, 子表将关联记录的关键字段所在列设为<code>null</code>， 因此设计子表时外键不能设为<code>not null</code></li><li><code>RESTRICT</code> : 如果子表中有关联父表的记录，那么想要删除父表记录时会不允许</li><li><code>NO ACTION</code> : 同<code>RESTRICT</code>，子表有匹配记录就不允许父表<code>update</code>/<code>delete</code></li></ul><p>但是，目前其实很多场景不需要数据库中的真实外键，只用设计逻辑外键就行<br>真实外键存在的情况下：</p><ul><li>一是不方便数据测试</li><li>二是高并发造成死锁</li><li>三是一致性事务完全交给数据库处理，很多时候资源占用高</li></ul><hr><h3 id="关键词查询-模糊匹配">关键词查询/模糊匹配</h3><p>涉及关键字查询或者模糊匹配的时候可以用 通配符模糊匹配、内置函数检索、正则匹配查询、全文索引</p><ul><li>通配符有 <code>%</code> <code>_</code> 加上<code>like</code>操作符</li><li>内置函数有 <code>instr()</code> <code>locate()</code> <code>position()</code> 等，语法接近</li><li><code>mysql</code> 支持绝大部分正则表达式功能，基于 <code>regexp</code>/<code>rlike</code> 等，基本涵盖所有需求</li><li>全文索引是<code>mysql</code>索引中的一种，支持字段格式包括<code>char</code>、<code>varchar</code>、<code>text</code>，语法为<code>match(#&#123;字段名&#125;) against(#&#123;keyWord&#125;)</code>。若不存在任何匹配结果，返回<code>0</code>；否则根据匹配次数多少和位置先后返回一个匹配度。</li></ul><hr><h3 id="布尔值">布尔值</h3><p>true, false, 1 , 0</p><p><code>mysql</code>中没有内置布尔类型，使用<code>tinyint(1)</code>来作为其等效进行存储，同时提供<code>boolean</code>和<code>bool</code>作为<code>tinyint(1)</code>的同义词。<code>0</code>被认为是<code>false</code>，<code>非零值</code>被认为<code>true</code>。而默认使用<code>true</code>和<code>false</code>时，计算值为<code>1</code>和<code>0</code></p><hr><h3 id="NULL值与字符串空值">NULL值与字符串空值</h3><p>一般来说，<code>''</code>空值说的是字符串是空的，也就是个空串；而<code>NULL</code>值的是一个字段未知，即<code>unkonwn</code>,两者不能混为一谈</p><p>特别注意，针对于NULL值是有特殊的处理运算符的：<code>IS NULL</code>, <code>IS NOT NULL</code>，所以用<code>=</code>、<code>!=</code>、<code>&gt;</code>、<code>&lt;</code>是不行的；<br>但是有一个特例：<code>&lt;=&gt;</code>运算，形如<code>exp &lt;=&gt; NULL</code>，如果<code>exp</code>的值是<code>NULL</code>，会返回<code>1</code></p><p>另外，有一些针对<code>NULL</code>的函数：</p><ul><li><code>IFNULL(exp)</code>: 如果<code>exp</code>的值为<code>NULL</code>，则返回<code>1</code>，否则返回<code>0</code></li><li><code>IFNULL(exp1, exp2)</code>: 如果<code>exp1</code>是<code>NULL</code>的话那么返回<code>exp2</code>的值，否则返回<code>exp1</code>的值</li><li><code>NULLIF(exp3, exp4)</code>：如果<code>exp3 = exp4</code>成立，那么返回<code>NULL</code>值，否则返回<code>exp1</code>值</li></ul><hr><h3 id="去重">去重</h3><p>一般常用的去重方法有<code>distinct</code>和<code>group by</code></p><h4 id="distinct"><code>distinct</code>:</h4><p>用于<code>select</code>语句开头</p><ul><li>如果去重列具有<code>NULL</code>值，会保留一个<code>NULL</code>值并删除其他</li><li>多列去重的条件下，只有所有指定列的的列信息都相同才会认为此信息重复</li></ul><h4 id="group-by-：">group by`：</h4><p>通常和聚合函数如<code>count()</code>、<code>max()</code>等一起使用，放在<code>where</code>条件之后</p><ul><li>可以单列/多列去重(<code>mysql5.7</code>之后默认<code>SQL</code>模式包括<code>ONLY_FULL_GROUP_BY</code>，默认要求使用<code>group by</code>时去重列即查询列。可以打破，重新设置)</li><li>去重的时候，<code>group by</code>会根据去重字段分组，如果数据相同那么就会分到一个组里面，再返回每个组的第一条数据，完成去重</li></ul><p>效率的话，<code>mysql8.0</code>之前<code>group by</code>有个隐式排序：</p><blockquote><p>在Mysql8.0之前,Group by会默认根据作用字段（Group by的后接字段）对结果进行排序。在能利用索引的情况下，Group by不需要额外进行排序操作；但当无法利用索引排序时，Mysql优化器就不得不选择通过使用临时表然后再排序的方式来实现GROUP BY了。且当结果集的大小超出系统设置临时表大小时，Mysql会将临时表数据copy到磁盘上面再进行操作，语句的执行效率会变得极低。这也是Mysql选择将此操作（隐式排序）弃用的原因。</p></blockquote><p>所以，从8.0开始，在语义相同，不论有无索引的情况下二者效率相同；<br>在8.0之前，如果没有索引，<code>group by</code>会进行隐式排序，触发<code>filesort</code>，效率低</p><p>另外： 有的场景需要<strong>针对去重之后的数据作统计</strong>，可以使用<code>count()</code>函数，以去重字段为计数条件</p><hr><h3 id="连接查询">连接查询</h3><p>一般连接查询的语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select column from table1 #&#123;连接方式&#125; table2 on #&#123;连接条件&#125;</span><br></pre></td></tr></table></figure><h4 id="内连接inner-join">内连接<code>inner join</code></h4><p>这种方式是提取两张表的共同点，即交集；且是系统默认的连接方式，可以省略<code>inner</code></p><h4 id="左连接left-join">左连接<code>left join</code></h4><p>此方式查询左表<code>table1</code>的的全部内容以及右表<code>table2</code>中符合条件的记录，如果<code>table2</code>中有些字段没有匹配到会默认使用<code>NULL</code>补充代替</p><h4 id="右连接right-join">右连接<code>right join</code></h4><p>同理，查询右表<code>table2</code>的全部内容和左表<code>table1</code>符合条件记录，<code>NULL</code>补充未匹配上字段</p><p>连接查询后面时常还会加另外的限制条件，<code>where</code>、<code>having</code>等</p><hr><h3 id="using关键字">using关键字</h3><p>连接查询时可以用<code>on</code>作为连接条件，同样也可以用<code>using</code>，两者效果一致：<br><code>using(#&#123;某个字段&#125;)</code> <code>=</code> <code>on table1.#&#123;同名字段&#125; = talbe2.#&#123;同名字段&#125;</code></p><p>注意：</p><ul><li><code>using</code>关键字针对的是同名字段</li><li>使用<code>using</code>之后在拼接表中会自动合并对应字段为一个</li><li><code>using</code>支持同时使用多个字段</li></ul><hr><h3 id="count-函数">count()函数</h3><p>条件计数的话里面经常和别的函数一起用，比方说<code>if</code>，针对某个字段的某个条件计数可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(if($&#123;condition&#125;, 1, null))</span><br></pre></td></tr></table></figure><p>这样写的原因是：<code>coount()</code>只要该行有值就会统计，<code>null</code>才不计</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring-Boot注意点(1)</title>
      <link href="/2023/12/23/blog13/"/>
      <url>/2023/12/23/blog13/</url>
      
        <content type="html"><![CDATA[<h2 id="记录SpringBoot使用时的一些小坑大雷">记录SpringBoot使用时的一些小坑大雷</h2><hr><h3 id="返回结果类Result要有get-set方法">返回结果类<code>Result</code>要有<code>get set</code>方法</h3><p>否则会报错：<br><code>HttpMediaTypeNotAcceptableException</code><br>或者前端调用接口会返回 406 状态码 即客户端无法解析服务端内容</p><h4 id="错误原因：">错误原因：</h4><p>客户端请求期望与服务器响应的媒体类型不一致，一般都是用json格式（控制器使用<code>@RestController</code>注解）；如果<code>Result</code>类没有<code>get set</code>方法会在对象转换成json时出问题</p><hr><h3 id="不要忘记扫描-注入mapper">不要忘记扫描/注入<code>mapper</code></h3><p>有时使用自动生成的代码可能没有<code>@Mapper</code>注解，这可能会导致项目启动失败</p><h4 id="解决">解决:</h4><ul><li>在<code>mapper.java</code>类加上注解<code>@Mapper</code></li><li>或者在启动类上标注<code>@MapperScan($&#123;path&#125;)</code>,<code>path</code>是<code>mapper.java</code>类的所在目录（目的是扫描到所需类）</li></ul><hr><h3 id="RequestBody注解不能用在Get方法中"><code>@RequestBody</code>注解不能用在<code>Get</code>方法中</h3><p>其实这个算网络的知识点，<code>Get</code>请求的参数是通过<code>url</code>方法传递而不是请求体，所以无法用<code>@RequestBody</code>注解接收</p><h4 id="解决：">解决：</h4><ul><li>将请求方法转换为<code>Post</code></li><li>使用多个<code>RequestParam</code>接受后拼装成对象</li><li>使用<code>@ModelAttribute</code>注解</li><li>使用<code>JSON</code>格式接收数据，再转化为对象</li></ul><hr><h3 id="对于依赖循环">对于依赖循环</h3><p>这个太容易发生了，特别是架构设计没规划好的时候，写着写着就报错了</p><h4 id="解决-2">解决</h4><ol><li>使用<code>@Lazy</code>注解，对一个<code>Bean</code>进行延时加载。注入代理，使用时才被完全初始化</li><li><code>Setter</code>/<code>Field</code>注入，实际上依赖没有被注入，只有需要时才被注入</li><li><code>@Autowired</code>注解将<code>required</code>属性设置为<code>false</code><br>等等，不止这些</li></ol><p>其实真正合理且符合架构设计准则的是重构，解耦规划</p><p><strong>对于依赖循环的底层下次可以好好唠唠</strong></p>]]></content>
      
      
      <categories>
          
          <category> SpringBoot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java概念(1)</title>
      <link href="/2023/12/22/blog12/"/>
      <url>/2023/12/22/blog12/</url>
      
        <content type="html"><![CDATA[<h2 id="Java笔记概念篇">Java笔记概念篇</h2><h3 id="Java-Edition"><code>Java Edition</code></h3><ol><li><code>Java SE</code> <code>(Java Platform, Stadard Edition)</code>:</li></ol><blockquote><p><code>Java</code>平台标准版，<code>Java</code>的基础部分（通常学校所教、一般所称的<code>Java</code>语言），包含程序开发、运行所需核心类库以及虚拟机等核心组件。可用于构建桌面应用程序、简单服务器程序。</p></blockquote><p>最基本的语言环境</p><ol start="2"><li><code>Java EE</code> <code>(Java Platform, Enterprise Edition)</code>:</li></ol><blockquote><p><code>Java</code>平台企业版，在<code>Java SE</code>基础之上建立而来，包含企业级应用程序和部署的标准、规范。早前的<code>Servlet</code>、<code>JSP</code>、<code>JDBC</code>等等。<code>Java EE</code> 可用于构建分布式、可移植、健壮、可伸缩、安全的服务端<code>Java</code>应用程序。</p></blockquote><p>大概就是单单一个<code>Java SE</code>是没法满足企业开发需要，配套标准之后方便与其他应用程序联合开发（数据库、各种中间件）</p><ol start="3"><li><code>Java ME</code> <code>(Java Platform, Micro Edition)</code>：</li></ol><blockquote><p><code>Java</code>的微型版本，主要用于开发嵌入式应用程序。</p></blockquote><p>很早的一个东西，我记得Sun公司刚开始就是往这方面做，现在基本无了（ <code>C++</code>, <code>C</code>这些比<code>Java</code>更适合）</p><hr><h3 id="JVM、JIT、JRE、JDK">JVM、JIT、JRE、JDK</h3><h4 id="JVM-Java-Virtual-Machine"><code>JVM</code> (<code>Java Virtual Machine</code>)</h4><p><code>Java</code> 虚拟机，用以运行<code>Java</code>字节码，是一个利用软件技术虚构出来的计算机，也是一种规范</p><p><code>Java</code>程序运行的过程：源文件(.java) -&gt; 编译器 -&gt; 字节码(.class) -&gt; 解释器 -&gt; 机器码</p><p><code>JVM</code>类加载器加载字节码文件，然后解释器逐行解释生成机器码，机器码交给系统之后，系统会与硬件交互完成工作。而解释器这一步就是由<code>JVM</code>调配执行，<code>JVM</code>针对不同系统进行解释器不同的实现，使得相同字节码在不同系统下运行出相同结果<br><strong>JVM具体细节日后再补充</strong></p><h4 id="JIT-Just-In-Time-Compilation"><code>JIT</code> <code>(Just In Time Compilation)</code></h4><blockquote><p>运行时编译，是一种技术，一般在<code>JVM</code>中使用。其在完成第一次编译后，会将字节码对应的机器码保存，以便下次直接使用(部分方法或代码块运行频繁，<code>JIT</code>就会把这部分“热点代码”编译成本地机器对应的机器码，并缓存。<code>JVM</code>会根据代码执行情况收集信息并相应给出优化)</p></blockquote><h4 id="JRE-Java-Runtime-Environment"><code>JRE</code> <code>(Java Runtime Environment)</code></h4><blockquote><p><code>Java</code>运行时环境，是运行已编译<code>Java</code>程序所需所有内容的集合，包含<code>Java</code>虚拟机<code>(JVM)</code>、<code>Java</code>基础类库<code>(Java Class Library)</code></p></blockquote><h4 id="JDK-Java-Development-Kit"><code>JDK</code> <code>(Java Development Kit)</code></h4><blockquote><p><code>Java</code>开发工具包，能够创建和编译<code>Java</code>程序，包含<code>JRE</code>以及一些其他工具比如<code>jdb</code>（调试器）、<code>javadoc</code>（文档注释工具）等</p></blockquote><p><code>JVM-JRE-JDK</code>三者关系：<br><img src="/2023/12/22/blog12/jdk-include-jre.png" class="lazyload" data-srcset="/2023/12/22/blog12/jdk-include-jre.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt></p><p><strong>注</strong>： <code>Java9</code>引入模块化和<code>jlink</code>，可以使用<code>jlink</code>打包一个程序运行时映像，只需要打包所需的特定包，借此来提供运行时环境并且减少内存和消耗</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java+Go-代码应用(1)</title>
      <link href="/2023/12/22/blog11/"/>
      <url>/2023/12/22/blog11/</url>
      
        <content type="html"><![CDATA[<h2 id="Java和Go具体代码的使用">Java和Go具体代码的使用</h2><h3 id="Java之List去重">Java之List去重</h3><p>有时业务场景需要针对一个 <code>List</code> 中的数据进行去重</p><p>如果是根据类对象去重可能还好，甚至不用重写 <code>hashCode()</code>方法和 <code>equals()</code>方法；</p><p>但是如果对对象中某个成员变量去重，就稍显麻烦，这时候可以借助 <code>java8</code> 的特性来去重</p><p>例如下语句，实现 <code>users</code>列表 中针对 <code>name</code>属性 去重，得到新的不含 <code>name</code>重复项 的 <code>deleteRepeatUsers</code> 列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Problem&gt; deleteRepeatUsers = users.stream().collect(</span><br><span class="line">                Collectors.collectingAndThen(</span><br><span class="line">                    Collectors.toCollection( </span><br><span class="line">                        () -&gt; <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(</span><br><span class="line">                            Comparator.comparing(User::getName))),</span><br><span class="line">                            ArrayList::<span class="keyword">new</span>)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>.stream()</code> 将 <code>users</code> 转换为一个流，后续使用流操作处理</li><li><code>.collect()</code> 和 <code>.Collectors.toCollection()</code> 都用于将流中元素收集到一个集合<code>(Collection)</code>中，后者返回一个收集器<code>(Collect)</code></li><li><code>Collectors.collectingAndThen()</code>包装另一个收集器，用于在使用其他收集器收集数据后对产生一个最终的结果（中转站）</li><li><code>() -&gt; new TreeSet&lt;&gt;(Comparator.comparing(User::getName))</code>是一个<code>Lambda</code>表达式，表示一个无参构造函数的引用：创建一个新的<code>TreeSet</code>对象，并传递一个<code>Comparator</code>，通过<code>User:getName</code>方法引用定义排序（过滤）规则</li></ul><p>综上，<code>users</code>转换成流收集后，数据经过<code>TreeSet</code>去重再转换回<code>ArrayList</code>容器</p><h3 id="Go之make-函数">Go之make()函数</h3><blockquote><p>make(type, len, cap)</p></blockquote><ul><li><code>type</code> : 数据类型</li><li><code>len</code>  : 实际占用空间</li><li><code>cap</code>  : 预留空间</li></ul><p><strong>内存分配</strong>： 先是只会去用<code>len</code>的空间，如果空间不够，再去拿<code>cap</code>的空间，这样避免了二次内存分配，提高效率。如果<code>cap</code>的空间或者在未指定<code>cap</code>的情况下<code>len</code>的空间满了，就会再进行动态内存分配策略，再去申请当前内存的相同空间，于是内存变为两倍</p>]]></content>
      
      
      <categories>
          
          <category> Code </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker小记(1)</title>
      <link href="/2023/12/22/blog10/"/>
      <url>/2023/12/22/blog10/</url>
      
        <content type="html"><![CDATA[<h2 id="docker速查小手册">docker速查小手册</h2><p>记录一些<code>docker</code>常用指令</p><h3 id="查看镜像">查看镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker images</span><br></pre></td></tr></table></figure><h3 id="查看容器">查看容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker ps -a</span><br></pre></td></tr></table></figure><h3 id="进入正在运行的容器">进入正在运行的容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it $&#123;容器id&#125; bash</span><br></pre></td></tr></table></figure><h3 id="提交容器修改，保存为镜像">提交容器修改，保存为镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit $(容器id) $&#123;仓库名&#125;:$&#123;版本号&#125;</span><br></pre></td></tr></table></figure><h3 id="删除镜像">删除镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rmi $&#123;镜像id(可只取前3字符)&#125;</span><br></pre></td></tr></table></figure><h3 id="停止-启动容器">停止/启动容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker start/stop $&#123;容器id(可3字符)&#125;</span><br></pre></td></tr></table></figure><h3 id="删除容器（停止容器之后）">删除容器（停止容器之后）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker rm $&#123;容器id(可3字符)&#125;</span><br></pre></td></tr></table></figure><h3 id="查看容器详细信息">查看容器详细信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker inspect $&#123;容器id(可3字符)&#125;</span><br></pre></td></tr></table></figure><h3 id="查看容器日志">查看容器日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker logs $&#123;容器id(可3字符)&#125;</span><br></pre></td></tr></table></figure><h3 id="进入容器">进入容器</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker exec -it $&#123;容器id(可3字符)&#125; /bin/bash</span><br></pre></td></tr></table></figure><h3 id="导出、导入">导出、导入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker save -o $&#123;导出路径/文件名及后缀(.tar.gz)&#125; $&#123;需要导出的镜像ID(可3字符)&#125;</span><br><span class="line">sudo docker load -i $&#123;导入路径/文件名及后缀(.tar.gz)&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo docker export $&#123;需要导出的容器id(可3字符)&#125; &gt; $&#123;导出路径/文件名及后缀(.tar)&#125;</span><br><span class="line">sudo docker import $&#123;导入路径/文件名及后缀(.tar)&#125; $&#123;镜像名&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式区别</strong>：</p><ol><li>首先，<code>export</code>命令是从容器(<code>container</code>)中导出<code>tar</code>文件，而<code>save</code>命令是从镜像(<code>image</code>)中导出</li><li>文件大小不同：<code>export</code>导出的镜像文件小于<code>save</code>保存的镜像</li><li>是否支持对镜像重命名：<ul><li><code>import</code>命令可以为镜像指定新名称</li><li><code>load</code>命令不能对载入镜像重命名</li></ul></li><li>是否支持将多个镜像打包到一个文件：<ul><li><code>export</code>不支持</li><li><code>save</code>支持</li></ul></li><li>是否包含镜像历史：<ul><li><code>export</code>导出(<code>import</code>导入)是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息，即其仅保存容器当时的快照状态，所以无法进行回滚操作</li><li><code>save</code>保存(<code>load</code>加载)的镜像，没有丢失镜像的历史，可以回滚到之前的层(<code>layer</code>)</li></ul></li><li>应用场景：<ul><li><code>export</code>主要用来制作基础镜像，作为开发的基础环境</li><li><code>save</code>是将用到的镜像打包，然后拷贝到不能连接外网的服务器上并用<code>load</code></li></ul></li></ol><h3 id="容器之间互相复制文件">容器之间互相复制文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp $&#123;容器id(可3字符)&#125;:$&#123;容器内路径&#125; $&#123;目标容器id(可3字符)&#125;:$&#123;目标容器内路径&#125;</span><br></pre></td></tr></table></figure><h3 id="基于当前容器创建镜像">基于当前容器创建镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker commit -a &quot;作者信息&quot; -m &quot;描述信息&quot; $&#123;容器id(可3字符)&#125; $&#123;镜像名:$&#123;版本号&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="docker-run">docker run</h3><p>用于根据指定的镜像创建和启动一个新的容器，</p><p>基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure><p>执行流程：</p><blockquote><p>第一步，在指定镜像上创建一个可写的容器层<br>第二步，使用指定命令(<code>COMMAND</code>)启动<br>简而言之，<code>docker run</code>相当于执行两个<code>API</code>: <code>/containers/create、/containers/(id)/start</code></p></blockquote><p><code>OPTIONS</code>说明：</p><blockquote><p><code>-i</code>，以交互模式运行容器，通常与 <code>-t</code> 同时使用<br><code>-t</code>，启动容器后，为容器分配一个命令行，通常与 <code>-i</code> 同时使用<br><code>-v</code>，目录映射，容器目录挂载到宿主机目录，格式： <code>&lt;宿主机目录&gt;:&lt;容器目录&gt;</code><br><code>-d</code>，守护进程，后台运行该容器<br><code>-p</code>，指定端口映射，格式：<code>主机(宿主)端口:容器端口-P</code>，随机端口映射，容器内部端口随机映射到主机的端口<br><code>-u</code>，以什么用户身份创建容器<code>--name &quot;容器名字&quot;</code><br><code>-m</code>, <code>--memory bytes</code>，设置容器使用内存最大值<br><code>-h</code>, <code>--hostname string</code>，指定容器的宿主机名<br><code>--dns</code>指定容器 dns 服务器<br><code>-e</code> 设置环境变量<br><code>--restart</code>，Docker重启后，容器是否自动重启<br><code>--privileged</code>，容器内是否使用真正的<code>root权限</code></p></blockquote><p>很多指令随用随查即可，也可以直接加<code>--help</code>查看帮助信息</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法小记(1)</title>
      <link href="/2023/12/22/blog9/"/>
      <url>/2023/12/22/blog9/</url>
      
        <content type="html"><![CDATA[<h1>算法小笔记</h1><h3 id="背景-闲话">背景(<s>闲话</s>)</h3><p>好久没更了，这不到年底了。想想马上2024了，干脆把之前的东西整理整理吧</p><h2 id="向上取整技巧-x-div-y">向上取整技巧 $x \div y$</h2><p>一般来说，刚开始都会想到两种方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = x % y == <span class="number">0</span> ? x / y : x / y + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = Math.ceil(x / y);</span><br></pre></td></tr></table></figure><p>实际上，第一种还行，但是稍显啰嗦；第二种容易出<code>bug</code>，而且调用消耗高。</p><p>有<strong>更简单</strong>的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = (x + y - <span class="number">1</span> ) / y</span><br></pre></td></tr></table></figure><p>简单证一下：</p><blockquote><p>假设 :<br> $x \div y = a \cdots b$,<br>那么:<br> $x = a \cdot y + b$,<br>则<br>  $(x + y - 1 ) \div y$<br>$= (a \cdot y + y + b - 1 ) \div y $<br>$= a + (y + b - 1) \div y$<br>如果 $b = 0 $，<br><br>那么后半部分就是 $0$ 了; <br><br>如果 $b \geq 1 $，<br><br>也就是不能整除，$a$ 就会 $+ 1$;<br><br></p></blockquote><h2 id="二分板子">二分板子</h2><p>nnd, 今天每日一题有思路，知道拿二分，也肯定能过但是居然卡二分实现这儿了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * nums为查找范围(升序排列)， target即目标</span></span><br><span class="line"><span class="comment"> * 现在查找nums数组中大于等于target的第一个数的下标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">pubulic <span class="type">int</span> <span class="title function_">dichotomy</span><span class="params">(<span class="type">int</span> [] nums , <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span> , right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">resLabel</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="comment">/* 循环条件注意 = ，即某一个位置需要判断是否符合*/</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 注意防溢出，也可以写成：</span></span><br><span class="line"><span class="comment">        int mid = left + (right - left &gt;&gt; 1) </span></span><br><span class="line"><span class="comment">           注意移位运算符的优先级*/</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">            resLabel = mid;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 有时候也根据需要直接把 mid 赋给 left/right */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resLabel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我之前老想不清的是找到第一个满足条件的数，需要借助前一次查找的标记。但是实际上，在窗口移动的过程中，范围一直在缩小、寻找满足条件且最靠前的数，缩到最小(到达最优解)后下次就会不满足条件直接跳出了。</p><h2 id="求解最短路">求解最短路</h2><h3 id="1-floyd-弗洛伊德算法">1. <code>floyd</code>(弗洛伊德算法)</h3><p><code>floyd</code>算法是把一个图里边的各个点之间的最短路都算出来，适合多源最短路问题</p><p>就是每拿到一个点，就借助这个点建立其他点之间的联系，更新其他点之间的最短路</p><p>朴素<code>floyd</code>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 弗洛伊德算法朴素式，借助矩阵实现</span></span><br><span class="line"><span class="comment">     * 给定一个 n 节点的图，</span></span><br><span class="line"><span class="comment">     * 且参数包含边权矩阵 edges[][]，其内层大小为 3 , 分别表示 起点，终点，路径长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> [][] floydSimplicity(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 建立并初始化距离矩阵</span></span><br><span class="line">    <span class="type">int</span>[][] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        Arrays.fill(dis[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将距离加入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> [] edge : edges)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>], to = edge[<span class="number">1</span>], len = edge[<span class="number">2</span>];</span><br><span class="line">        dis[from][to] = len;</span><br><span class="line">        dis[to][from] = len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三层遍历得到所有点之间的最短路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span> ; k &lt; n ; k ++)&#123;</span><br><span class="line">        dis[k][k] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">                dis[i][j] = Math.min(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-dijkstra-迪杰斯特拉算法">2. <code>dijkstra</code>(迪杰斯特拉算法)</h3><p><code>dijkstra</code>算法是从一个点出发，不断更新此点到其他点的最短路，直到所有点都到达或者遍历完。适合单源最短路问题，但同样也可用于多源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 下面先针对多源最短路问题给出dijkstra朴素实现，条件同上</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> [][] dijkstraSimplicity(<span class="type">int</span> n, <span class="type">int</span>[][] edges)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 建立并初始化距离矩阵和路径矩阵</span></span><br><span class="line">    <span class="type">int</span>[][] dis = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">    <span class="type">int</span>[][] map = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建访问矩阵，标记某个位置是否作为最近点使用过</span></span><br><span class="line">    <span class="type">boolean</span>[][] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        Arrays.fill(dis[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">        Arrays.fill(map[i], Integer.MAX_VALUE / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将边权加到路径矩阵中，方便后续直接使用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> [] edge : edges)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>], to = edge[<span class="number">1</span>], len = edge[<span class="number">2</span>];</span><br><span class="line">        map[from][to] = len;</span><br><span class="line">        map[from][to] = to;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i ++)&#123;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>; <span class="comment">// 每个点到自身距离为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ; j ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">shortPos</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 寻找最近的点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span> ; k &lt; n ; k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !vis[i][k] &amp;&amp; (shortPos == -<span class="number">1</span> || dis[i][k] &lt; dis[i][shortPos]))&#123;</span><br><span class="line">                    shortPos = k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            vis[i][shortPos] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 借助最近点去算到其他点的距离，不断更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span> ; k &lt; n ; k ++)&#123;</span><br><span class="line">                dis[i][k] = Math.min(dis[i][k], dis[i][shortPos] + map[shortPos][k]);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Arithmetic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记一次失败的双周赛</title>
      <link href="/2023/11/12/blog8/"/>
      <url>/2023/11/12/blog8/</url>
      
        <content type="html"><![CDATA[<h2 id="赛后">赛后</h2><h3 id="让我唠唠">让我唠唠</h3><p><s>这次的双周赛，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很菜，我是真的很</s></p><div class="note "><p>谢谢，上面这是<code>AI</code>给我写的。不过也是实话，giao , byd😡还挺懂我是吧</p></div><p>昨天，双十一，秋风萧瑟，哥们儿一个人搁寝室独自力扣单排双周赛。第二题坐牢。</p><p>啊，平常卡三四也理解，第二想着怎么优化就是不行(<s>不排除是白天xdoj写多了降智</s>)</p><p>来题： <a href="https://leetcode.cn/problems/distribute-candies-among-children-ii/">给小朋友们分糖果II</a></p><h3 id="正文">正文</h3><p>当时因为放在第二题，数据规模比第一题要高，所以我估摸着直接开第二题，弄完再开三四，好家伙，直接给我卡这儿了</p><h4 id="第一题">第一题</h4><p><s>先来水一下</s></p><p>链接： <a href="https://leetcode.cn/problems/distribute-candies-among-children-i/">给小朋友们分糖果I</a></p><p>数据规模很小，所以实际上可以双层<code>for</code>直接暴力过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCandies</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span> ; num1 &lt;= limit ; num1 ++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="number">0</span> ; num3 &lt;= limit ; num3 ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(n - num1 - num2 &gt;= <span class="number">0</span> &amp;&amp; n - num1 - num2 &lt;= limit)&#123;</span><br><span class="line">                    res ++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 没啥好说的，只需要三个人的数据都在 0~limit 之间即可</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="第二题">第二题</h4><h5 id="我的想法">我的想法</h5><p><code>kid</code> : 小朋友</p><p><code>candy</code> : 糖果数量</p><p>因为是给3个小家伙分，所以考虑的情况是很少的，我就想着首先<code>kid1</code>拿，然后<code>kid2</code>，再是<code>kid3</code>，所以初始状态就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">candy1</span> <span class="operator">=</span> Math.min(n, limit);</span><br><span class="line"><span class="type">int</span> <span class="variable">candy2</span> <span class="operator">=</span> Math.min(n - candy1, limit);</span><br><span class="line"><span class="type">int</span> <span class="variable">candy3</span> <span class="operator">=</span> Math.min(n - candy1 - candy2, limit);</span><br></pre></td></tr></table></figure><p>现在起始状态有的，肯定是 $ candy1 \geq candy2 \geq candy3$，所以我想的维持这个状态，这样只需要看这三个糖果数是哪种情况：</p><ul><li>$ a, a, a $</li><li>$ a, a, b $ 或者 $ a, b, b $</li><li>$ a, b, c $<br>可以假想成各个情况下，糖果的分法</li></ul><ol><li>第一种情况，那么就是$A_3^0 = 1$</li><li>第二种，$A_3^1 = 3$</li><li>第三种，$A_3^2 = 6$<br>写一个方法或者函数来判断当前处于哪种情况，然后累加即可</li></ol><p>但是，它这个分配策略太繁琐了，有</p><ol><li><code>candy1</code> -&gt; <code>candy2</code></li><li><code>candy1</code> -&gt; <code>candy3</code></li><li><code>candy2</code> -&gt; <code>candy3</code><br>调了很久没想明白(应该有<code>dp</code>的思想)，加上交了几发都错了，就寄啦😝</li></ol><h5 id="学来的-对，我就是剽窃智慧doge">学来的(对，我就是剽窃智慧doge)</h5><p>每次赛后都习惯看看榜前面的<code>Java</code>代码，然后<s>给自己一巴掌</s>复盘</p><p>其实可以这样想：</p><p>首先，$ candy1 $从$ 0 $开始迭代，终止条件为$ \leq limit $ 和 $\leq n$，<br>然后剩下的先给$ candy2 $，</p><ul><li>如果$ candy2 \leq limit $ ，那这种策略下分配方式是$ candy2 + 1 $</li><li>如果$ candy2 &gt; limit $，那就令$ candy2 = limit $，然后剩下的再减去$limit$，再给$ candy3 $这种策略下分配方式是$ limit - candy3 + 1 $</li></ul><p>关于分配方式，这里只需要看$ candy2 $ 和 $ candy3 $，二者在满足条件的情况下分配方式是$ candy2 - candy3 + 1 $</p><p>所以代码可以这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">distributeCandies</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> <span class="number">0</span> ; num1 &lt;= limit &amp;&amp; num1 &lt;= n; num1 ++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rest1</span> <span class="operator">=</span> n - num1;</span><br><span class="line">            <span class="keyword">if</span>(rest1 &lt;= limit)&#123;</span><br><span class="line">                res += rest1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//int num2 = limit ;</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 这里把num2 直接省掉了，</span></span><br><span class="line"><span class="comment">                 * 因为num2 已经被赋值为limit了，</span></span><br><span class="line"><span class="comment">                 * 所以这里直接用limit 即可</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">num3</span> <span class="operator">=</span> rest1 - limit;</span><br><span class="line">                <span class="keyword">if</span>(num3 &lt;= limit)&#123;</span><br><span class="line">                    res += limit - num3 + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挺好理解的，就是按常规的枚举来的实际上。用不着看糖果数来算方案。</p><p>ε=(´ο｀*)))唉，每次都是第二题想复杂，不需要其实。</p><p>还有，下次写公式记得在<code>front-matter</code>里开一下<code>mathjax</code>，还为这找了会儿<code>bug</code>😠</p>]]></content>
      
      
      <categories>
          
          <category> Arithmetic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(除草水文)回顾and计划</title>
      <link href="/2023/10/16/blog7/"/>
      <url>/2023/10/16/blog7/</url>
      
        <content type="html"><![CDATA[<h2 id="一个多月想了很多">一个多月想了很多</h2><p>真是快捏，翻开博客才发现原来已经一个多月没有更了😓，中间修过几次小bug，但是一直没有好好沉下来写写文章</p><p>想想啊，这个月，<code>XDU-Inspur</code>纳新、新项目接手、给小家伙写文档，还有骤然增加的课程，唉，比暑假可挤占时间多了(那时候还能熬熬夜，现在修修<code>bug</code>第二天都头疼的不行 😇)</p><p>再有呢，陆陆续续关注秋招，观察老东西们的出路，我也在思考自己的规划，之前好像慢慢的就是往开发这方面靠，虽然写的大项目不多，但是感觉这方面还是比较适合自己。大一进来想着保研，然后就被高数当头一棒，索性一狠心来计科逼自己一把好好学技术（当然，以前也是想来这儿的）。科研、研究生的氛围着实不是很痴迷（虽然家里人总是喊着读个研😥），相反，自己学一些感兴趣的技术、算法or小玩意儿倒是更好玩儿。但这毕竟是吃饭的家伙什，关系到未来的生活捏，所以技术要精进往深了挖。</p><h3 id="回首">回首</h3><p>想想啊，目前会的：</p><ol><li>语言方面：<code>C</code>,<code>C++</code>,<code>Python</code>,<code>JavaScript</code>,<code>Java</code>，其中<code>C</code>基本所有语法都用过，而且算比较熟悉（毕竟就那么些东西）；<code>C++</code>的话类这块儿比较薄弱的，自己去专门做一个<code>demo</code>好像比较少，一般都是写题调个<code>STL</code>；<code>Python</code>的话帮别人写过一个大作业、跟着书写过一个本地小游戏；<code>Js</code>的话之前学前端学过，但是挺浅的（<code>html</code>、<code>css</code>随用随查了）；<code>Java</code>就老伙计了，常用语法是熟悉的😋</li><li>框架：<code>SpringBoot</code>+<code>Mybatis-plus</code>+<code>Vue</code>，主要还是后端，毕竟本行了</li><li>数据库：<code>Mysql</code>+<code>Redis</code>，感觉都是只会用，做<code>crud</code>这些😭</li><li>算法方面：基本数据结构都了解的，图和树做的少，别的都有，力扣180题（池子也挺浅的）+其他平台的一些题，周赛常年两题选手</li><li>操作系统：最近实验室装了个<code>ubuntu</code>玩玩儿(玩儿熟了自己也装一个)，手里还有两台服务器（私人+Inspur），也差不多指令是即用即搜，<code>bash</code>脚本没有系统去学</li></ol><p>giao，这么一列发现没会多少，而且还比较浅，不少都是会用，底层原理这些就不懂了(恼)😑</p><h3 id="以后">以后</h3><p>既然确实打算走这条路了，那就踏踏实实走下去，也确实需要大大滴😀踏实沉淀：</p><ul><li><input type="checkbox" id="checkbox3"><label for="checkbox3"></label><code>Java</code>的并发编程、反射机制，集合源码，<code>IO流</code>深入的东西，还有<code>jvm</code>的实现、调优</li><li><input type="checkbox" id="checkbox4"><label for="checkbox4">继续学习</label><code>Spring</code>这一套框架，<code>SpringCloud</code>、<code>SpringSecurity</code>这些碰的不多，还得研究研究底层逻辑，最好去读读源码，自己做做扩展</li><li><input type="checkbox" id="checkbox5"><label for="checkbox5">数据库这块儿沉到底下去学学</label></li><li><input type="checkbox" id="checkbox6"><label for="checkbox6">分布式这一块儿的学习需要提上日程了，可以适当在项目中加入</label></li><li><input type="checkbox" id="checkbox7"><label for="checkbox7">计网好好学，操作系统很重要，计组也是</label></li><li><input type="checkbox" id="checkbox8"><label for="checkbox8">继续练算法，尽量每日一题+周赛，剑指offer和hot100刷完；适量打一打算法竞赛</label></li><li><input type="checkbox" id="checkbox9"><label for="checkbox9">项目的话，最后投实习就选出一个轮子+一个业务放简历上</label></li></ul><p>总结一下，就是项目+八股+算法</p><h3 id="最后">最后</h3><p>不要懈怠或者浪费不必要的时间😠</p><p>八股笔记整理整理正好可以发发<code>blog</code><s>就当水文了</s></p><p>嗯…还要综合学校文化课、实验、社团等等杂七杂八的东西，还得注意注意身体，越来越肥宅力</p><p>保持开心捏😊</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>准大二军训期间的遐想</title>
      <link href="/2023/09/02/blog6/"/>
      <url>/2023/09/02/blog6/</url>
      
        <content type="html"><![CDATA[<h2 id="一些杂想during军训">一些杂想during军训</h2><hr><p>想想啊，从上次更算法之后，基本在vue的学习和leetcode刷题中度过，然后觉得之前博客的主题过于花里胡哨，想弄得简介点儿，于是花了两天时间重新配置和部署，再之后貌似就军训了？？？</p><p>唉，去年没训留到了现在</p><p>军训嘛，自然身体上的锻炼更多，至于思绪，可以随意飞扬飘到哪儿就是哪儿…</p><p>在酷日的暴晒之下，静静琢磨琢磨两道算法题，也有更多时间和心境想想这些和那些（<s>虽然很多时候也会烦躁和无奈</s>）</p><p>也许是反省和鞭挞？自己也常干这事儿…</p><hr><h3 id="change-mind😇">change mind😇</h3><p>我觉得自己以前，至少初高中时期，是个把苦难磨砺当成阶梯的人。每次身边人都在抱怨埋汰的时候，自己都是默默忍受和服从，像孙少平一样接受苦难、享受苦难。</p><p>军训之前，我也觉得不就是累点儿吗，站会儿有什么大不了的。被训的时候我也是这样想着，喉咙痛着着了凉也是继续训着。但是经过<s>xiao ling dao</s>某些人的一系列不合理措施打击之后，好像更多的是无奈失望。😰我开始想这些东西的合理存在性，以及我对待其的态度想法。</p><p>逆来顺受不是对的；能吃苦是对的；存在不一定合理，也不一定不合理；自己到底有没有认真思考过当下、以前这些苦难的意义？</p><p>我自己也没有清楚的定义，但是我想我应该想的多，像章北海，要多想。我觉得苦难本身对我的定义应该是一种正反馈机制，死撑是不是一种感动自己？考虑效益最大化是最终目的吗？</p><hr><h3 id="cultivate-personality😌">cultivate personality😌</h3><ul><li>不记得何时起社恐成为我逃避某些场合的最正当理由，也不记得何时起某些瞬间会有外表相当内敛和内心的张狂糅合成一个矛盾体，冷漠自私与热烈感性也是我。</li><li>从小到大，好像有好多时候感叹做这个事儿的为什么不是我，我明明可以做的更好。可是我又清楚知道机会不偏向怯懦者。</li><li>无数个时刻痛恨Ta的丑恶嘴脸和行为的同时自己转头却坐着同样的事；向君子品格看齐却永远调不过来。</li></ul><p>想的不够，做的不够；随性的同时应该是不失竹兰之风的；冷静不能以失去善良为代价。还要学的有很多捏</p><hr><h3 id="control-spirit😆">control spirit😆</h3><p>理性不够，头脑貌似越来越不理智而是跟着感觉和情绪走。从很小很小的时候起，哥们儿就希望自己能够好好地控制自己的情绪。似乎现在越走越远。。。</p><p>军训静坐的时候，平心静气的那种感觉也好久没有体会到了。</p><p>做感兴趣的事儿固然有趣，但是不喜欢的事儿自己好像越来越不能让自己去尝试，社交、人际、接触，好多好多…</p><hr><h3 id="look-forward😐">look forward😐</h3><p>有些事儿总是埋在心头，不知道是阴影还是回忆。自己不去揭，但好像某些时刻会自动冒出来，我不停的告诫自己都是过去式，仰望以后吧。</p><p>也不算多坏吧，自己一手造就不能怨谁。</p><p>现在也不算太烂吧，至少哥们儿没有陷太久。</p><p>陆陆续续遇到很好的人啦，同龄，年长，更幼，或并肩或教导或领携，睡一觉什么都能过去。</p><hr><h3 id="keep-avtive😋">keep avtive😋</h3><p>不做悲观主义者，尽管自己知道脑子里应该是乐观主义占优，但悲观主义总是冒头出来捣乱，加剧内耗和焦虑</p><p>保持热爱和善良，不尽纯粹，但有清明</p><p>少emo啦，小事情啦~~</p><p>多笑笑捏</p><h3 id="over😴">over😴</h3><p>翻翻上面，好像不知道写了啥，又好像都写了，有点儿<em>零表涕零，不知所言</em>那味儿？</p><p>睡力~~~</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我眼中的KMP算法</title>
      <link href="/2023/08/17/blog5/"/>
      <url>/2023/08/17/blog5/</url>
      
        <content type="html"><![CDATA[<h1>KMP算法小解</h1><h2 id="水背景😜"><s>水背景</s>😜</h2><p>很早就想更一更题解，力扣也好，洛谷也好，写写题，记录一下思路和算法，<s>想想就很爽</s>😇</p><p>陆陆续续碰到过不少难题（对我而言）和马叉虫的题（不难但是思想特别好、需要一定脑回路的）</p><hr><h2 id="正文">正文</h2><p>KMP碰到过不少次，最早应该是在XD教学oj上做字符串的题，再后来是力扣，洛谷貌似也遇到过？当时暴力能过，看了看KMP的题解，头都大了（<s>猪脑过载</s>🐷），大致看了半懂就扔收藏夹吃灰辽</p><p>最近翻出来，<s>热热还能吃</s>琢磨看看</p><p>目前力扣是主战场，所以就贴一下那边原题罢：<a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/?envType=list&amp;envId=YLAs5ki1">找到字符串中第一个匹配项的下标</a>，本文也对标此题</p><p>虽然标的难度是<font color="#00aa00">简单</font> ，但是应该是指暴力解法，KMP方法还是需要好好想想的😪</p><h3 id="暴力解法">暴力解法</h3><p>虽然平平无奇，还是写写分析对比一下（doge）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    haystack 为主串</span></span><br><span class="line"><span class="comment">    needle 为模式串</span></span><br><span class="line"><span class="comment">    如果找到匹配项，return 主串匹配处的第一个字符下标; 否则 return -1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> ,</span><br><span class="line">        lenH = haystack.length(), </span><br><span class="line">        lenN = needle.length();</span><br><span class="line">        <span class="keyword">while</span>(i + lenN &lt;= lenH)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; lenN)&#123;</span><br><span class="line">                <span class="keyword">if</span>(haystack.charAt(i + j) != needle.charAt(j))&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(j == lenN)&#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            i ++;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的目标很简单，找到匹配下标，所以每次未匹配成功的话直接 break ，同时索引 j 都会再次回到 0 位置。</p><p>😬这样的时间复杂度是O(lenH*lenN)，和KMP比起来是相当差的：</p><p><img src="/2023/08/17/blog5/blog5leetcode1.png" class="lazyload" data-srcset="/2023/08/17/blog5/blog5leetcode1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="提交结果"></p><h3 id="KMP解法">KMP解法</h3><p>我们其实可以发现，在暴力解法中，虽然索引 i 表面上看起来没有动，但是实际上起比较作用的是 i + j 和 j , i 只是匹配失败后回溯到了 i + 1 位置而已。相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> ,</span><br><span class="line">        lenH = haystack.length(), </span><br><span class="line">        lenN = needle.length();</span><br><span class="line">        <span class="keyword">while</span>(i &lt; lenH &amp;&amp; j &lt; lenN)&#123;</span><br><span class="line">            <span class="keyword">if</span>(haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                i ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                i = i - j + <span class="number">1</span>;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == lenN)&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>回溯后的比较其实有很多是之前已经比过的</strong>，而这些地方恰恰是我们要利用的😆</p><p>Knuth-Morris-Pratt 算法，简称KMP算法，其消除了主串索引 i 的回溯，从而提高匹配效率。</p><p>在KMP算法中，i 是不能回退的，我们借助的是将 j 回退一定的步数。问题是应该回退多少步？<strong>理想情况下回退后要保证 i 左侧的字符和 j 左侧的字符能够匹配</strong>，这个时候就需要我们的前缀数组 next [] 了</p><h4 id="求解前缀数组-next">求解前缀数组 next []</h4><p>一点前置知识：</p><ul><li><strong>前缀</strong>： 从串首到某个位置i结束的一个子串，即s[0…i]</li><li><strong>真前缀</strong>：除完整串s之外的前缀部分，相当于不看最后一个字符得到的前缀</li><li><strong>后缀</strong>：从某个位置开始到串尾结束的子串，即s[i…|s|-1]</li><li><strong>真后缀</strong>：同理喽，除s外的后缀，相当于不看第一个字符</li><li><strong>最长公共真前后缀</strong>：顾名思义，就是真前后缀里边都有，而且最长的那条子串</li></ul><p>比如对于串 example = “nice” 有：<br>前缀： n, ni, nic, nice<br>真前缀： n, ni, nic<br>后缀： e, ce, ice, nice<br>真后缀： e, ce, ice<br>最长公共真前后缀： 为空</p><p><strong>对于KMP算法我们需要关注模式串needle的最长真前后缀</strong></p><p>给出一个 int 数组 next [] ，其大小与needle长度相等，其元素 next[t] = k 是对于子串 s[0:t-1] 的最长公共真前后缀长度 k ，即 s[0:k-1] = s[p-k:p-1]，k 也叫做失效长度，同时也就是 <strong>j 需要回退到的位置</strong>（根据最长公共真前后缀的性质，回退之后 i 和 j 左侧是完全匹配的，符合我们的要求）😮</p><h5 id="求解思想">求解思想</h5><ol><li>首先next[0] = -1 ，因为 0 - 1 = -1 ，已经超过最小索引无法再移动了，这相当于一个标志（所以将 -1 改为其他负数也行）</li><li>其次next[1] = 0 , 因为对于单个字符的子串，其真前后缀为空串，长度为 0</li><li>需要两个索引，p(position) 和 v(value), 分别用来记录子串右侧字符位置和子串对应的最长公共真前后缀长度。同时将 p 初始化为0，v 初始化为 next[0] 对应值</li><li>当 needle.charAt(p) == needle.charAt(v)时，表示最长公共真前后缀可以加长，所以next[ ++p ] = ++ v;</li><li>如果 needle.charAt(p) != needle.charAt(v)，现在前后缀对不上，那么 v 就需要往前找更短的最长公共真前后缀，又是回溯！注意我们现在拿着的正是 <strong>next []</strong> ！！！所以<strong>不需要返回串首，直接 v = next[v]</strong>，这里相当重要😎</li><li>综上，v 有可能回到 next[0] ，所以当 v = next[0] 时，进行 v = 0 ; next[ ++p ] = 0;</li></ol><h6 id="对上述思想中的4进行验证">对上述思想中的4进行验证</h6><p>我们假设已知 next[p] (p &gt; 1) == k , 即 needle[0:k-1] == needle[p-k:p-1]<br>如果 needle[k] == needle[p] ，那么就有 needle[0:k] == needle[p-k:p], 即 next[p+1] = k + 1 ，与思想4符合</p><p>至于5的话，我没有找到/想到特别恰当的文字描述，感觉抽象地说也好理解😝</p><h5 id="求解代码">求解代码</h5><p>将上述思想转化成代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> [] getNext(String needle)&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">lenN</span> <span class="operator">=</span> needle.length();</span><br><span class="line">    <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span> [lenN];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1222</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , v = next[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">while</span>(p &lt; lenN - <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v == next[<span class="number">0</span>])&#123;</span><br><span class="line">            next[++p] = v = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(needle.charAt(p) == needle.charAt(v))&#123;</span><br><span class="line">            next[++p] = ++v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            v = next[v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果将next[0] 设为 -1，代码会更简洁：😆</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> [] getNext(String needle)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">lenN</span> <span class="operator">=</span> needle.length();</span><br><span class="line">       <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span> [lenN];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , v = -<span class="number">1</span>;</span><br><span class="line">       next[p] = v;</span><br><span class="line">       <span class="keyword">while</span>(p &lt; lenN - <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(v == -<span class="number">1</span> || needle.charAt(p) == needle.charAt(v))&#123;</span><br><span class="line">               next[ ++p ] = ++ v ;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               v = next[v] ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> next; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p>到这里基本上已经完成主要工作了，但是还不够：<br>实际跑的过程中，next 数组还会有一点缺陷，比如：<br>haystack = “aaaabcc” , needle = “aaaac”<br>根据之前的思路，int [] next = {-1, 0, 1, 2, 3} ；<br><strong>注意</strong>：当 i 走到 4 ，j 走到 4 时 haystack.charAt(i) = ‘b’ 与 needle.charAt(j) = ‘c’ 首次匹配失败，那么 j 回退到 next[4] 即 3 , needle.charAt(j) = ‘a’ ，再次匹配失败，再次回退，结果还是’a’，还是需要回退，这样也会增加时间消耗。最理想的情况就是一下子直接回退成功，跳过中间元素重复的位置。</p><p>可以想到，因为 haystack 与 needle 匹配失败的时候有 j = next[j],<br>而 next[] 由 v 更新而来，我们需要跳过匹配失败的元素，所以重源头修改，当检查到元素重复我们直接跳到 next[v]：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> [] getNext(String needle)&#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">lenN</span> <span class="operator">=</span> needle.length();</span><br><span class="line">       <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span> [lenN];</span><br><span class="line">       <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , v = -<span class="number">1</span>;</span><br><span class="line">       next[p] = v;</span><br><span class="line">       <span class="keyword">while</span>(p &lt; lenN - <span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span>(v == -<span class="number">1</span> || needle.charAt(p) == needle.charAt(v))&#123;</span><br><span class="line">               <span class="keyword">if</span>(needle.charAt( ++p ) == needle.charAt( ++ v))&#123;</span><br><span class="line">                   next[p] = next[v];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   next[p] = v;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               v = next[v] ;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> next; </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>修改算法之后求得的 next [] = {-1, -1, -1, -1, 3}，符合预期效果😀</p><h4 id="完整代码">完整代码</h4><p>哦了，next [] 数组算完了，整体代码也就完工了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> , j = <span class="number">0</span> , </span><br><span class="line">        lenH = haystack.length(),</span><br><span class="line">        lenN = needle.length();</span><br><span class="line">        <span class="comment">// 获取 next []</span></span><br><span class="line">        <span class="type">int</span> [] next= getNext(needle);</span><br><span class="line">        <span class="keyword">while</span>( i &lt; lenH &amp;&amp; j &lt; lenN)&#123;</span><br><span class="line">            <span class="keyword">if</span>( j == -<span class="number">1</span> || haystack.charAt(i) == needle.charAt(j))&#123;</span><br><span class="line">                i ++;</span><br><span class="line">                j ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 匹配失败，回退</span></span><br><span class="line">                j = next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j == lenN)&#123;</span><br><span class="line">            <span class="keyword">return</span> i - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> [] getNext(String needle)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenN</span> <span class="operator">=</span> needle.length();</span><br><span class="line">        <span class="type">int</span> [] next = <span class="keyword">new</span> <span class="title class_">int</span> [lenN];</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span> , v = -<span class="number">1</span>;</span><br><span class="line">        next[p] = v;</span><br><span class="line">        <span class="keyword">while</span>(p &lt; lenN - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v == -<span class="number">1</span> || needle.charAt(p) == needle.charAt(v))&#123;</span><br><span class="line">                <span class="keyword">if</span>(needle.charAt( ++p ) == needle.charAt( ++ v))&#123;</span><br><span class="line">                    next[p] = next[v];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    next[p] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                v = next[v] ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次的时间复杂度是O(lenH + lenN)了，空间复杂度会略有增加😋<br><img src="/2023/08/17/blog5/blog5leetcode2.png" class="lazyload" data-srcset="/2023/08/17/blog5/blog5leetcode2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="提交结果"></p>]]></content>
      
      
      <categories>
          
          <category> Arithmetic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聊聊Bootstrap(BS)</title>
      <link href="/2023/07/31/blog4/"/>
      <url>/2023/07/31/blog4/</url>
      
        <content type="html"><![CDATA[<h1>瞎扯一扯我眼中的Bootstrap</h1><p>力扣写不下去力（晕），来写写博客<s>划划水</s>理一理脑子</p><h2 id="日常水背景"><s>日常水背景</s></h2><p>最近在弄浪潮这边静态网页的设计和美化：<br><img src="/2023/07/31/blog4/ISC1.png" class="lazyload" data-srcset="/2023/07/31/blog4/ISC1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="图1"></p><p>感谢Bootstrap这种对我这样的<s>菜鸡</s>后端er极其友好的框架，整体写的还算顺利，除了博客这块儿采用的mkdocs外，剩下都是靠的BS（救！）</p><p>所以写写自己的浅显认知罢，理一理坑和小tips</p><h2 id="正片开始">正片开始</h2><p>首先，依然坚持我的观点，官方文档是最好的学习资料和手册</p><p>扔：</p><ul><li><a href="https://v5.bootcss.com/">Bootstrap官方</a></li><li><a href="https://www.bootstrap.cn/doc/book/2.html">民间大神翻译站</a></li></ul><p>平常要用到的啥随时<s>CV</s>查用即可</p><h3 id="日常使用引入">日常使用引入</h3><p>框架使用官方讲的很清楚，用CDN可以，下载源文件也可以</p><p><strong>注</strong>： <strong>CDN</strong>即内容分发网络( Content Delivery Network )，采用缓存服务器并将其放在用户相对集中的地区或网络，用户访问时，利用全局负载技术，将访问指向最近的缓存服务器上响应请求（类似电商本地仓库）采用CDN可以大大提升访问速度、提升安全性等</p><p>对于Bootstrap来讲，使用者的CSS和JS配置文件都写好了放在不远的地方，引入一下，相当于直接从云端扒下来使用</p><p>所以，开发者使用时只需要专注HTML文件，考虑布局、细节即可，需要的组件都已经写好了</p><p>Bootstrap官方也说：&quot; HTML和CSS优于JS &quot;，所以站在这个角度俺觉得它更像个组件库</p><p>还是说说具体用法，这里也有注意点来着，写写罢，怕自己也忘了</p><h4 id="1-使用CDN">1.使用CDN</h4><p>CSS引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-GLhlTQ8iRABdZLl6O3oVMWSktQOp6b7In1Zl3/Jr59b6EGGoI1aFkw7cmDA6j6gD&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript引入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js&quot;</span> <span class="attr">integrity</span>=<span class="string">&quot;sha384-/mhDoLbDldZc3qpsJHpLogda//BVZbgYuw6kof4u2FrCedxOtgRZDTHgHUhOCVim&quot;</span> <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>属性说明：</strong></p><ul><li>href 和 src 很明显嘛，html里常用的，用以资源指向定位</li><li>rel 也很常见，定义链接资源和当前文档关系</li><li>剩下这俩可能就比较少见了，一般都是在用CDN引入第三方库的时候碰到，<strong>intergrity</strong> 用以开启浏览器对获取的资源进行检验(借助hash值查验文件是否经过篡改)，比如此处就是使用sha384算法对下载的文件进行计算并和intergrtiy提供的摘要签名比对；<strong>crossorigin</strong>定义元素如何处理跨源请求，实现对该元素获取数据的CORS(跨源资源共享，一种基于HTTP头的机制)请求配置。（此处其实两者实现机制和逻辑都比较复杂）</li></ul><h4 id="2-直接下载">2.直接下载</h4><p>这个就比较简单粗暴了，当然，官方为了让开发者自定义功能，也提供了<strong>生产文件</strong>和<strong>源码</strong>两种模式，后者稍麻烦，一般来讲Bootstrap已经把功能实现的可以了，拿来用就行</p><p>下载解压文件夹后，选出<strong>bootstrap.min.css</strong>和<strong>bootstrap.bundle.min.js</strong>就行，涵盖绝大部分需要了</p><h3 id="一些使用tips">一些使用tips</h3><p>趁还记得，先写上（笑）</p><h4 id="网格and列布局">网格and列布局</h4><p>这个相当好用，很容易作出简介整齐的布局</p><ol><li>响应断点：<strong>xs、sm、md、lg、xl、xxl</strong> ， 对应尺寸：576px、768px、960px、1200px、1400px</li><li>一行12格，各列分配，放不下就跑下一行</li><li>.row-cols-可以直接指定一行的列数，不用在各个.col上写</li></ol><h4 id="卡片">卡片</h4><ul><li>其实我觉得卡片只是把元素边框明显化了的块区域，用div(一把梭选手<s>就是我</s>)也能实现差不多的效果</li><li>和列结合，设计出水平变化的卡片</li><li>.card-group实现卡片群组，自动对齐（这个也有点儿列表的意思）</li><li>.h-设置高度，用以同行卡片对齐美观</li></ul><h4 id="位置">位置</h4><p>这玩意儿有时候特别容易出bug</p><ol><li>.align-items-和.align-self-指定垂直对齐，控制水平排布;.justify-content-指定水平对齐，控制垂直排布</li><li>.flex弹性盒子结合上者可以特殊设置元素位置，排版方便</li><li>.start-、.end-、.top-、.bottom-、.translate-middle可以强制指定位置</li></ol><h4 id="其他">其他</h4><ul><li>常使用.d–none 和 .d–block结合控制特定尺寸下元素的显示方式</li><li>轮播结合长宽比比较好看</li><li>模态弹框、滑动导航可以把大量文本隐藏，点击后显示，方便布局</li><li>工具提示可以放在链接、按钮上增加交互</li></ul><p>貌似就这些我觉得比较好用的（当然，前端菜狗<s>后端也是</s>）</p><h2 id="小结">小结</h2><p>反正给我带的感觉吧，Bootstrap适合做一些比较小型或者页面简单的静态站，做起来真挺方便，而且部署直接一丢就行（当然，别的框架打包也是相当方便的）</p><p>鱼摸完了，溜~~</p>]]></content>
      
      
      <categories>
          
          <category> Frontend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Mybatis-Plus(1)</title>
      <link href="/2023/07/15/blog3/"/>
      <url>/2023/07/15/blog3/</url>
      
        <content type="html"><![CDATA[<h1>聊一聊关于mybatis-plus的日常开发</h1><hr><h2 id="背景：">背景：</h2><ul><li>日常开发中，Dao层(Date Access Object)作为数据访问层，承载大量的数据交互处理，直接联系数据库，服务于业务逻辑</li><li>这里就不得不提到mybatis，一款非常优秀的持久层框架，直接免除传统JDBC代码，通过注解、xml配置数据对象映射即可实现数据CRUD(增删改查)</li><li>而mybatis-plus作为国产之光，由国人苞米豆团队在mybaits基础上进一步增强，上手更为快速</li></ul><p>(小声，贴一下<strong>mybaitis</strong>和<strong>mybatis-plus</strong>官方文档：)<br>=&gt;<a href="https://mybatis.org/mybatis-3/zh">mybstis</a><br>=&gt;<a href="https://baomidou.com/">mybatis-plus</a></p><hr><h2 id="spring-boot项目中使用mybatis-plus-推荐IDEA为开发工具">spring-boot项目中使用mybatis-plus(推荐IDEA为开发工具)</h2><ol><li>项目maven配置文件pom.xml中引入依赖:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    &lt;!-- mybatis-plus --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.5</span><span class="number">.3</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis-plus代码生成器 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.5</span><span class="number">.3</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- freemarker 代码生成器的模板，不要忘了引入--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.freemarker&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;freemarker&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>我日常使用数据库即mysql，所以引入mysql依赖：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- mysql--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>在配置文件application.yml或application.properties中配置数据库连接：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line"> datasource:</span><br><span class="line">     username: &quot;对应数据库用户名&quot;</span><br><span class="line">     password: &quot;对应密码&quot;</span><br><span class="line">     url: jdbc:mysql:///&quot;项目对应数据架构&quot;</span><br></pre></td></tr></table></figure><ol><li>在IDEA中写项目的话最好装一个mybatisX插件,写自定义sql的时候比较方便<br><img src="/2023/07/15/blog3/mabatisX.png" class="lazyload" data-srcset="/2023/07/15/blog3/mabatisX.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="mybatisX"></li></ol><hr><h2 id="日常使用">日常使用</h2><h3 id="1-代码生成器">1. 代码生成器</h3><p>这玩意儿用了一次就知道多方便了，自动生成四层：<br><img src="/2023/07/15/blog3/mabatis-plus-codegenerator.png" class="lazyload" data-srcset="/2023/07/15/blog3/mabatis-plus-codegenerator.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="贴图"><br><strong>注</strong>: 它是根据数据架构自动生成的实体类、控制层等等，一张表对应一个实体类</p><ul><li>具体代码可以看mybatis-plus文档的</li><li>贴一张项目截图示例：<br><img src="/2023/07/15/blog3/mybatis-plus-codegeneratorcode.png" class="lazyload" data-srcset="/2023/07/15/blog3/mybatis-plus-codegeneratorcode.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="代码生成器配置示例"></li></ul><hr><h3 id="2-普通service层CRUD接口">2.普通service层CRUD接口</h3><p>mybatis-plus为开发者封装了不少可以直接调用的CRUD接口</p><ul><li>Get</li><li>Save</li><li>Remove</li><li>Update<br><strong>均支持泛型，详见官方文档</strong></li></ul><hr><h3 id="3-条件构造器wrapper">3.条件构造器wrapper</h3><ul><li>Wrapper: 条件构造抽象类，最顶端父类</li><li>AbstractWrapper: 用于查询条件封装</li><li><strong>QueryWrapper</strong>: Entiry对象封装操作类</li><li><strong>UpdateWrapper</strong>: update条件封装</li><li>AbstractLambdaWrapper: Lambda语法使用Wrapper统一处理解析</li><li><strong>LambdaQueryWrapper</strong>: 使用Lambda语法查询</li><li>LambdaUpdateWrapper: Lambda语法更新</li></ul><p>条件构造器根据sql语法转换了许多的函数，如eq,gt等，这个一搜就很多</p><p><strong>注</strong>：日常使用时最多用的是<strong>QueryWrapper、UpadateWrapper、LambdaQueryWrapper</strong>，前者使用条件构造函数时可以使用lambda()方法将该条件转化为lambda语法，<u>这个有时候需要注意</u></p><p>使用示例：<br><img src="/2023/07/15/blog3/wrapperUsing.png" class="lazyload" data-srcset="/2023/07/15/blog3/wrapperUsing.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="wrapper示例"></p><hr><h3 id="4-自定义sql">4.自定义sql</h3><p>mybatis-plus当然也是支持自定义sql语句的，可以使用@select，@update等注解(暂时没怎么用)或者在Mapper.xml中书写自定义方法<br>如：<br>mapper.xml文件示例：<br><img src="/2023/07/15/blog3/mybatis-plus-self-sql1.png" class="lazyload" data-srcset="/2023/07/15/blog3/mybatis-plus-self-sql1.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="Mapper.xml"><br>mapper层对应文件示例:<br><img src="/2023/07/15/blog3/mybatis-plus-self-sql2.png" class="lazyload" data-srcset="/2023/07/15/blog3/mybatis-plus-self-sql2.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt><br><strong>注</strong>：在Mapper.xml中除了select可以指定返回值外，别的都不可以有</p><hr><h2 id="小结：">小结：</h2><p>mybatis-plus属实是生产力工具，极大简化开发步骤(spring也有功劳)，但是目前耳易老师写的项目还太少，还是很多地方没用到(<s>冰山一角</s>)</p><p>上述所有相关内容只是个人近期的一个小梳理，在脑海中留个印象(<s>猪脑不好使</s>)</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql（1）</title>
      <link href="/2023/07/04/blog2/"/>
      <url>/2023/07/04/blog2/</url>
      
        <content type="html"><![CDATA[<h1>由web项目引发的对mysql建表时的思考和注意</h1><hr><h2 id="背景">背景</h2><p>之前ISC这边接手了一个开发项目，做一个志愿活动服务平台，因为开发经验不够，拿到手建表只考虑了用户信息和角色信息的关联，<s>猪脑过载</s>没想到活动这块儿，可想而知，接口写着写着就发现写不下去，表得重写（<s>悲</s>）</p><h2 id="建表过程">建表过程</h2><h3 id="1-角色分区">1. 角色分区</h3><p>考虑到关系逻辑，我干脆把用户信息和角色信息绑定，直接把区分区分角色建表：volunteer、organizer、regulator三张角色表<br>然后每个角色有最基本的用户信息id（各表主键）,name（唯一键）,password（加密存储）,phone,email,avatar（存储存放头像文件的路径）</p><h4 id="根据不同的角色再细化特性字段：">根据不同的角色再细化特性字段：</h4><ul><li>volunteer设置了志愿积分、参与活动数目统计、参与活动的最大限制数量、志愿状态<br>建表语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">create table volunteer</span><br><span class="line"> (</span><br><span class="line">   id             int auto_increment</span><br><span class="line">       primary key,</span><br><span class="line">   name           char(32)      not null,</span><br><span class="line">   password       varchar(64)   null,</span><br><span class="line">   phone          char(12)      null,</span><br><span class="line">   email          varchar(32)   null,</span><br><span class="line">   avatar         varchar(64)   null,</span><br><span class="line">   score          int default 0 null,</span><br><span class="line">   activity_count int default 0 null,</span><br><span class="line">   activity_max   int default 0 null comment &#x27;限制最大参与活动数&#x27;,</span><br><span class="line">   status         int default 0 not null,</span><br><span class="line">   deleted        int default 0 null,</span><br><span class="line">   constraint volunteer_u</span><br><span class="line">     unique (name)</span><br><span class="line"> )</span><br><span class="line">   comment &#x27;志愿者表&#x27;;</span><br></pre></td></tr></table></figure><ul><li>organizer比较特殊的是一个限制最大活动发布数<br>建表语句：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   create table organizer</span><br><span class="line">(</span><br><span class="line">    id           int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    name         char(32)      not null,</span><br><span class="line">    password     varchar(64)   not null,</span><br><span class="line">    phone        char(12)      not null,</span><br><span class="line">    eamil        varchar(32)   null,</span><br><span class="line">    avatar       varchar(64)   null,</span><br><span class="line">    activity_max int default 0 null,</span><br><span class="line">    deleted      int default 0 null,</span><br><span class="line">    constraint organizer_u</span><br><span class="line">        unique (name)</span><br><span class="line">)</span><br><span class="line">    comment &#x27;组织者表&#x27;;</span><br></pre></td></tr></table></figure><ul><li>regulator的话有个等级字段（打算的是陆续开放冻结用户、删除用户权限）<br>建表：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   create table regulator</span><br><span class="line">(</span><br><span class="line">    id       int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    name     char(32)      null,</span><br><span class="line">    password varchar(64)   not null,</span><br><span class="line">    phone    char(12)      not null,</span><br><span class="line">    email    varchar(32)   null,</span><br><span class="line">    avatar   varchar(64)   null,</span><br><span class="line">    rate     int default 1 null comment &#x27;管理等级&#x27;,</span><br><span class="line">    deleted  int default 0 null,</span><br><span class="line">    constraint regulator_pk</span><br><span class="line">        unique (name)</span><br><span class="line">)</span><br><span class="line">    comment &#x27;管理者表&#x27;</span><br></pre></td></tr></table></figure><h4 id="注意：">注意：</h4><ol><li>varchar和char的使用：varchar是可变长，char则是定长，存储时varchar省空间一点儿，但是查询效率不及char（数据量特别大时差距会明显一点儿），我这儿把name和phone设为char是后续要借助这俩字段来查重</li><li>字段deleted用于mybatis-plus的逻辑删除处理（即虚假删除），事务逻辑删除开启后，经过虚假删除的记录在数据库会继续存在，但是查询的时候是自动忽略的（<s>所以不要以为账户注销就万事大吉辽</s>）。</li></ol><hr><h3 id="2-活动管理">2.活动管理</h3><h4 id="活动表activity的建立及与organizer表的关联">活动表activity的建立及与organizer表的关联</h4><p>按照日常对于志愿活动的理解，设置了这些字段：id（主键），name(唯一键，活动不重名是为了用户查看历史信息时不会混淆), theme, organizer_id, data_time, location, volunteer_min, volunteer_max, volunteer_current_number, status, description, deleted</p><p>建表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">create table activity</span><br><span class="line">(</span><br><span class="line">    id                       int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    organizer_id             int           null,</span><br><span class="line">    name                     char(64)      null,</span><br><span class="line">    theme                    varchar(32)   null,</span><br><span class="line">    data_time                datetime      null,</span><br><span class="line">    location                 varchar(128)  null,</span><br><span class="line">    volunteer_min            int default 0 null comment &#x27;所需最小的志愿者数量&#x27;,</span><br><span class="line">    volunteer_max            int           null comment &#x27;所需志愿者最大数&#x27;,</span><br><span class="line">    volunteer_current_number int default 0 not null,</span><br><span class="line">    status                   int default 0 not null comment &#x27;活动状态&#x27;,</span><br><span class="line">    description              text          null comment &#x27;活动描述&#x27;,</span><br><span class="line">    deleted                  int default 0 null,</span><br><span class="line">    constraint activity_u</span><br><span class="line">        unique (name),</span><br><span class="line">    constraint activity_organizer_fk</span><br><span class="line">        foreign key (organizer_id) references organizer (id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注：</p><ol><li>其中organizer_id是关联organizer表中id的外键，与organizer表做到数据统一</li><li>status字段表示活动状态，不同整数代表不同状态，比如准备中、召集中、进行中、已完成等</li><li>description属于text数据类型，长文本哈，我的预期是把活动描述的字数控制在400字以内，这样也不会造成太大的查询效率影响</li><li>当参与志愿者数位于目标区间之内时，活动方可正式进行</li></ol><h4 id="activity与volunteer之间的关联">activity与volunteer之间的关联</h4><p>其实刚开始我想的是在志愿者表里面直接设置一些列，比如10列来存放活动id，和活动表关联起来，但是细想觉得很浪费空间，而且没有好好利用mysql这种关系型数据库的设计模式</p><p>所以我就新建了一个关系表activity_volunteer_relation，用来记录志愿者对于活动的参与情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table activity_volunteer_relation</span><br><span class="line">(</span><br><span class="line">    id           int auto_increment</span><br><span class="line">        primary key,</span><br><span class="line">    activity_id  int null,</span><br><span class="line">    volunteer_id int null,</span><br><span class="line">    constraint fk1</span><br><span class="line">        foreign key (activity_id) references activity (id),</span><br><span class="line">    constraint fk2</span><br><span class="line">        foreign key (volunteer_id) references volunteer (id)</span><br><span class="line">)</span><br><span class="line">    comment &#x27;记录志愿者参与活动情况&#x27;;</span><br></pre></td></tr></table></figure><p>字段id为主键，activity_id是关联activity的外键字段，volunteer_id是关联volunteer的外键字段，这样后面查询的时候直接根据活动id和志愿者id就能把记录查询出来，也不用担心volunteer的活动数改变的问题</p><hr><h2 id="思考">思考</h2><h3 id="关于数据表建表：">关于数据表建表：</h3><ol><li>数据类型选择。根据空间和效率来看哪个数据类型更合适放在这条记录中，日后开发高并发、高性能的项目时这点肯定会很重要（比如这次的varchar和char）</li><li>灵活处理关系。当对象关系比较杂乱的时候，分离出类来（没错，就是面向对象设计中的类），这本身也和java的观念吻合，实体类这一层也是这个思想。从对象之间关系的角度来设计表（类似volunteer和activity)</li></ol><hr><h3 id="雷点（可能是日后项目里面的坑）：">雷点（可能是日后项目里面的坑）：</h3><ol><li>有的字段可能还是不够合理，比方说activity的name，实际上应该允许存在不同主题下存在同名活动（<s>问题倒也不大</s>）</li><li>还有一些字段可能需要加，比如volunteer的等级、organizer的等级、信誉等等，随着等级的提升来对活动数目限制进行更改（这个改倒是方便，<s>也不算大坑</s>）</li></ol><hr><h2 id="结语">结语</h2><p>大致这些罢，SQL这边玩儿的还不多，命令行下手写语句还是很容易打错，可视化界面（尤其像DataGrip、IDEA这些<s>大赞</s>）下倒还好。</p><p>还有约束条件、手撸多表、分页查询也不熟，mysql的函数更是没用多少，耳易老师会慢慢<s>水水字</s>更，慢慢学</p>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲谈</title>
      <link href="/2023/06/28/blog1/"/>
      <url>/2023/06/28/blog1/</url>
      
        <content type="html"><![CDATA[<h1>关于编程生活的XDer杂谈</h1><h2 id="更新说明">更新说明</h2><p>​其实很久之前就正式搭好了博客，但是碍于种种原因没有好好写东西。大致可能是：</p><ol><li><s>学校</s>bi<s>事儿太多</s>。自己忙不过来，挤不出时间。想想去年一路走过来，从高考暑假学完C语法，去刷些基础题（计蒜客）。到西电以来，一下子被高数、程设打个措手不及。一波一波的作业和安排，自己还得抽空学java，C++，还有浪潮这边Web开发的各项技能SQL，Spring，JavaScript…<s>还是菜的一批</s>，博客一时还真是没弄</li><li>技术不够。这确实是事实。早先在洛谷写题的时候经常卡着（现在也卡），甚至学校那<s>破教学</s>oj上的题也有过不了的（恼）。再就是看到学长们Web技术的精湛，想写点儿啥害怕有点儿<s>嚣张</s>班门弄斧。陆陆续续看了数据结构之后又转战力扣，一度被简单题<s>完虐</s>爆锤。想写点啥又好像确实技术臭</li></ol><h2 id="该写力">该写力</h2><ul><li>其实身边不少同龄人琢磨博客这玩意儿，他们似乎不在乎自身水平（起码比我强），凭着一股热忱和<s>程序员</s><strong>码农</strong>特有的开源精神经常更博文</li><li>技术大概比以前精进了一丢丢罢，后端方向倒是会写几个接口，来点儿简单的算法题似乎也能应付。</li><li>本身有<s>复盘</s>批判自己又臭又旧代码的习惯，写博文那种娓娓道来的感觉类似于高中讲题的味儿（高中也一弱ji），能巩固点儿八股也好，巩固点儿代码能力也好，脑子不好多写罢</li><li>大学以来似乎人际局限更厉害（没有<s>妹子</s>社交），有时候想说点儿啥似乎机会也没有。高中旧情亦渐行渐远，那正好写写喜欢的东西罢</li></ul>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>first blog</title>
      <link href="/2022/11/25/hello-world/"/>
      <url>/2022/11/25/hello-world/</url>
      
        <content type="html"><![CDATA[<h1>这是第一次博客搭建成功时的默认页面</h1><ul><li>下面连接都是hexo（静态博客框架）的响应服务官网</li><li>留作纪念就不删辽</li></ul><h3 id="Create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> Test </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
